#include "xm_type.h"
#include "xm_comm_isp.h"
#include "xm_comm_sns.h"
#include "xm_sns_ctrl.h"
#include "mpi_isp.h"
#include "mpi_ae.h"
#include "mpi_awb.h"
#include "xm_awb_comm.h"

#include "xm_print.h"
#include "XAx_cmos.h"
#include "mpi_phyvi.h"
#define STATIC	static
extern XM_S32 cmos_set_mirror_flip_sc2235(XM_U8 u8Mirror,XM_U8 u8Flip);
extern void cmos_again_calc_table_sc2235(XM_U32 u32InTimes,AE_SENSOR_GAININFO_S *pstAeSnsGainInfo);
extern XM_VOID cmos_gain_calc_table_com(XM_U32 u32InTimes,AE_SENSOR_GAININFO_S *pstAeSnsGainInfo);
extern XM_VOID cmos_inttime_update_sc2235(XM_U32 u32IntTime);
extern XM_VOID cmos_gains_update_sc2235(XM_U32 u32Again, XM_U32 u32Dgain);
extern ISP_CMOS_SNS_ATTR_S gstSnsAttr;

const static XM_U16 gau16LogicAddr[6] = {
	0x3301,0x3306,0x3631,0x3632,0x3633,0x3622
};
const static XM_U8 gau8Logic_sc2235P[3][6][6] = {
	//  0x3301 0x3306 0x3631 0x3632 0x3633 0x3622
	//CVBS_PAL
	{
		{0x06, 0x48, 0x84, 0x08, 0x34, 0xC6},
		{0x11, 0x48, 0x88, 0x08, 0x11, 0xC6},
		{0x16, 0x48, 0x88, 0x08, 0x11, 0xC6},
		{0x14, 0x48, 0x88, 0x08, 0x42, 0x06},
		{0x90, 0x78, 0x88, 0x48, 0x42, 0x16},
		{0x90, 0x78, 0x88, 0x78, 0x42, 0x16}
	},
	//CVBS_NTSC
	{
		{0x05, 0x48, 0x84, 0x08, 0x34, 0xC6},
		{0x0e, 0x48, 0x88, 0x08, 0x11, 0xC6},
		{0x14, 0x48, 0x88, 0x08, 0x11, 0xC6},
		{0x11, 0x48, 0x88, 0x08, 0x42, 0x06},
		{0xac, 0x68, 0x88, 0x48, 0x42, 0x16},
		{0xac, 0x68, 0x88, 0x78, 0x42, 0x16}
	},
	//AHD
	{
		{0x06, 0x48, 0x84, 0x08, 0x34, 0xC6},
		{0x14, 0x48, 0x88, 0x08, 0x11, 0xC6},
		{0x18, 0x48, 0x88, 0x08, 0x11, 0xC6},
		{0x13, 0x48, 0x88, 0x08, 0x42, 0x06},
		{0xc5, 0x78, 0x88, 0x48, 0x42, 0x16},
		{0xc5, 0x78, 0x88, 0x78, 0x42, 0x16}
	}
};


const static XM_U16 gau16LogicAddr_Mipi[3] = {
	0x3301,0x3306,0x3632
};
const static XM_U8 gau8Logic_sc2235P_Mipi[6][3] = {
	//  0x3301 0x3306 0x3632 
		{0x06, 0x48, 0x08},
		{0x14, 0x48, 0x08},
		{0x18, 0x48, 0x08},
		{0x13, 0x48, 0x08},
		{0xc5, 0x78, 0x48},
		{0xc5, 0x78, 0x78}
};


void gainLogic_sc2235P(XM_U32 u32AllGain)
{
	static XM_U8 su8Idx = 0xFF;//[bit0~bit3]:Vstd   [bit4~bit7]:Agc
	XM_U8 u8Idx,u8Idx2,u8i;

	if(gu8Fps==50)		u8Idx = 0;
	else if(gu8Fps==60) 	u8Idx = 1;
	else					u8Idx = 2;
	if(u32AllGain<32)
		u8Idx2 = 0;
	else if(u32AllGain<64)
		u8Idx2 = 1;
	else if(u32AllGain<128)
		u8Idx2 = 2;
	else if(u32AllGain<248)
		u8Idx2 = 3;
	else if(u32AllGain<496)
		u8Idx2 = 4;
	else
		u8Idx2 = 5;
	if(	((su8Idx&0x0F) != u8Idx) ||
			((su8Idx>>4)&0x0F) != u8Idx2)
	{
		su8Idx = ((u8Idx2&0x0F)<<4)|(u8Idx&0x0F);
		sensor_write_register(0x3812, 0x00);
		if(gstSnsAttr.u8InputMode == SENSCONT_MIPI)
		{
			for(u8i=0; u8i<3; u8i ++)
			{
				sensor_write_register((XM_U32)gau16LogicAddr_Mipi[u8i], (XM_U32)gau8Logic_sc2235P_Mipi[u8Idx2][u8i]);
			}
		}
		else
		{
			for(u8i=0; u8i<6; u8i ++)
			{
				sensor_write_register((XM_U32)gau16LogicAddr[u8i], (XM_U32)gau8Logic_sc2235P[u8Idx][u8Idx2][u8i]);
			}
		}
		
		
		sensor_write_register(0x3812, 0x30);
	}
}



STATIC XM_VOID cmos_slow_framerate_set(XM_U16 u16FullLines, AE_SENSOR_DEFAULT_S *pstAeSnsDft)
{
	static XM_U16 preU16FullLine = 0xffff;
	if(preU16FullLine == u16FullLines)
		return;

	preU16FullLine = u16FullLines;
	u16FullLines = (u16FullLines>=4096)?4000:u16FullLines;
	pstAeSnsDft->u32MaxIntTime = u16FullLines - 4;
	SysDelay_ms(300);
	if(gu32ShutNow>pstAeSnsDft->u32MaxIntTime)
	{
		cmos_inttime_update_sc2235(pstAeSnsDft->u32MaxIntTime);
	}
	sensor_write_register(0x320e, (u16FullLines&0xff00)>>8);	
	sensor_write_register(0x320f, u16FullLines&0xff);

	XM_MPI_MIPI_RefreshFV(0, (XM_U32)u16FullLines);
}

STATIC XM_S32 cmos_set_mirror_flip(XM_U8 u8Mirror,XM_U8 u8Flip)
{
	XM_U32 u32Val,u32Reg3928;
	XM_U16 u16OfstV;

	u32Val = sensor_read_register(0x3221);
	u32Reg3928 = 0x01;	
	if(u8Mirror)
	{
		u32Val |= 0x06;
		u32Reg3928 = 0x05;
	}
	else
	{
		u32Val &= ~0x06;
	}
		
	if(u8Flip)
	{
		u32Val |= 0xe0;
		u16OfstV = 0;
	}
	else
	{
		u32Val &= ~0xe0;
		u16OfstV = 0;
	}
	sensor_write_register(0x3221, u32Val);
	sensor_write_register(0x3928, u32Reg3928);
	VI_WinSet(1, u8Mirror, u8Flip, 0, u16OfstV);
	XM_MPI_MIPI_RefreshFV(100, 0);
	return XM_SUCCESS;
}

static XM_VOID cmos_fps_set_sc2235P(XM_U8 u8Fps, AE_SENSOR_DEFAULT_S *pstAeSnsDft)
{
	XM_U32 u32TotalSizeV,u32Pixs=2640;
	u32TotalSizeV = HD1080P_LINES;
	switch(u8Fps)
	{
		case 30:
			u32Pixs = 2200;
			break;
		case 25:
			u32Pixs = 2640;
			break;
		// 12.5fps
		case 12:
			u32Pixs = 2640;
			u32TotalSizeV = HD1080P_LINES*2;
			break;
		// 15fps
		case 15:
			u32Pixs = 2200;
			u32TotalSizeV = HD1080P_LINES*2;
			break;
		// 10fps
		case 10:
			u32Pixs = 2640;
			u32TotalSizeV = HD1080P_LINES*25/10;
			break;
		default:
			//ERR("cmos_fps_set: fps err!\n");
			return;
			break;
	}		

	if(pstAeSnsDft != NULL) 
	{
		pstAeSnsDft->u32FullLinesStd = u32TotalSizeV;
		pstAeSnsDft->u32MaxIntTime = pstAeSnsDft->u32FullLinesStd-gu8MaxShutterOfst;
		pstAeSnsDft->u32LinesPer500ms = pstAeSnsDft->u32FullLinesStd * u8Fps / 2;
	}
	sensor_write_register(0x320c, (u32Pixs>>8)&0xFF);
	sensor_write_register(0x320d, u32Pixs&0xFF);
	sensor_write_register(0x320e, (u32TotalSizeV>>8)&0xFF);
	sensor_write_register(0x320f, u32TotalSizeV&0xFF);
	XM_MPI_MIPI_RefreshFV(0, (XM_U32)u32TotalSizeV);
	gu8Fps = u8Fps;
	return;
}


XM_S32 cmos_init_sensor_exp_function_sc2235P(ISP_SENSOR_EXP_FUNC_S *pstSensorExpFunc)
{
	pstSensorExpFunc->pfn_cmos_set_mirror_flip = cmos_set_mirror_flip;
	return 0;
}

XM_S32 cmos_init_ae_exp_function_sc2235P(AE_SENSOR_EXP_FUNC_S *pstExpFuncs)
{
	pstExpFuncs->pfn_cmos_fps_set           = cmos_fps_set_sc2235P;
	pstExpFuncs->pfn_cmos_slow_framerate_set= cmos_slow_framerate_set;    
	pstExpFuncs->pfn_cmos_inttime_update    = cmos_inttime_update_sc2235;
	pstExpFuncs->pfn_cmos_gains_update      = cmos_gains_update_sc2235;
	pstExpFuncs->pfn_cmos_again_calc_table  = cmos_again_calc_table_sc2235;
	pstExpFuncs->pfn_cmos_dgain_calc_table  = cmos_gain_calc_table_com;
	pstExpFuncs->pfn_cmos_shut_calc_table = NULL;
	return 0;
}

const AE_SENSOR_DEFAULT_V2_S gstAeSnsDef_sc2235p = {
	2, HD1080P_LINES-4,	// minInt   	maxInt
	1024,15872, 		// minAgain maxAgain
	128,128,				// minDgain 	maxDgain
	0xFFF,				// maxIspGain
	0x01000002,			// Update
	{700,700,700,700},
	0x00
};


#if(defined SOC_SYSTEM) || (defined SOC_ALIOS)
const ISP_CMOS_AGC_TABLE_S g_stIspAgcTable_sc2235P =
{
	/* bvalid */
	1,
	/* 100, 200, 400, 800, 1600, 3200, 6400, 12800; 100, 200, 400, 800, 1600, 3200, 6400, 12800 */
	//[0~7]:Normal						
	/* sharpen_D	H	*/
	{0x18,0x18,0x18,0x18,0x18,0x14,0x06,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04},
	
	/* sharpen_Ud M */
	{0x1C,0x1C,0x1C,0x1C,0x1C,0x18,0x10,0x10,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04},

	/* sharpen_Kd  */
	{0x2C,0x2C,0x2C,0x2C,0x28,0x18,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},
	
	/* snr_thresh 2DNr		*/
	{0x00,0x01,0x04,0x10,0x20,0x28,0x60,0x60,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40},

	/* snr_thresh 3DNr	 Tf	*/
	{0x02,0x03,0x05,0x08,0x0e,0x14,0x15,0x19,0x19,0x19,0x18,0x18,0x18,0x18,0x18,0x18},	

	/* snr_thresh 3DNr	 Sf	*/
	{0x00,0x00,0x00,0x04,0x0c,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10},  

	/* DyDpc_thresh 		*/
	{0x00,0x00,0x00,0x00,0x00,0xC0,0xD0,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8},
	
	/* saturation_strength */
	{0xA4,0xA4,0x9A,0x90,0x88,0x78,0x6A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
	
	/* Blc	*/
	{0x40,0x40,0x40,0x40,0x40,0x38,0x34,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30},

	/*Y_Tran gamma*/ 
	{0x32,0x32,0x32,0x31,0x2F,0x2D,0x38,0x38,0x38,0x38,0x28,0x28,0x28,0x28,0x28,0x28},
};

const ISP_AWB_CALIBRATION_V2_S gstAwbCal_sc2235P = {
#if 0
	{0, 0, 4096, 2630, 2612, 1580, 928, 3888},
	{4096, 3382, 0, 0, 3405, 2776, 4096, 2400},
	{-2078, -4096, -1742, -4096, -4096, -4096, -3296, -4096},
	213,
	0, 2300, 0, 3645,
	{0, 1515, 1885, 2148, 2258, 2468, 2728, 2765, 3645, 0, 0, 0, 0, 0, 0, 0},
	{2000, 2150, 2800, 4000, 4150, 5000, 6500, 7500, 12000, 0, 0, 0, 0, 0, 0, 0},
	{1480, 1024, 1196, 0}
#else
	{0, 0, 4096, 2539, 3818, 1871, 2161, 4096},
	{4096, 3653, 0, 0, 3614, 2556, 4096, 1316},
	{-1185, -4096, -1697, -4096, -4096, -4096, -3380, -2650},
	213,
	0, 1854, 0, 3208,
	{0, 992, 1297, 1609, 1702, 1838, 2089, 2128, 3208, 0, 0, 0, 0, 0, 0, 0},
	{2000, 2150, 2800, 4000, 4150, 5000, 6500, 7500, 12000, 0, 0, 0, 0, 0, 0, 0},
	{1396, 1024, 1425, 0} 
#endif
};

const ISP_COLORMATRIX_AUTO_S g_stAwbCcm_sc2235P =
{
	5000,
	{
		0x000,332, -58, -18,
		0x000,-50, 391, -85,
		//0x000,-20, -100, 376
		0x000,20, -100, 336
	},
	4000,
	{
		0x000,327, -72,  1,
		0x000,-46, 362,-60,
		0x000, -2,-149,407
	},
	2800,
	{
		0x000, 265,  24,-33,
		0x000,-102, 374,-16,
		0x000, -54,-272,582
	}
};


// ExtClk: 37.125M
static const XM_U16 gau16SnsInit_sc2235P_DVP[][2] = {
		{0x0100,0x00},
		{0x3039,0xa4},
		{0x3018,0x1f},
		{0x3019,0xff},
		{0x301c,0xb4},
		{0x3624,0x08},
		{0x5000,0x06},
		{0x3e08,0x03},
		{0x3e09,0x10},
		{0x337f,0x03},
		{0x3368,0x04},
		{0x3369,0x00},
		{0x336a,0x00},
		{0x336b,0x00},
		{0x3367,0x08},
		{0x330e,0x30},
		{0x3366,0x7c},
		{0x3302,0x1f},
		{0x303f,0x81},
		{0x3907,0x00},
		{0x3902,0xC5},	// 0x45
		{0x3905,0xb8},
		{0x3e01,0x8c},
		{0x3e02,0x10},
		{0x3e06,0x00},
		{0x3908,0x11},
		{0x335e,0x01},
		{0x335f,0x03},
		{0x337c,0x04},
		{0x337d,0x06},
		{0x33a0,0x05},
		{0x366e,0x08},
		{0x3637,0x59},
		{0x3326,0x00},
		{0x3303,0x20},
		{0x3638,0x1f},
		{0x3636,0x25},
		{0x3625,0x02},
		{0x331b,0x83},
		{0x3333,0x30},
		{0x3635,0xa0},
		{0x363c,0x05},
		{0x3314,0x13},
		{0x363b,0x0b},
		{0x3038,0xff},
		{0x3639,0x09},
		{0x3621,0x28},
		{0x366f,0x2f},
		{0x3320,0x01},
		{0x331e,0x19},
		{0x330b,0xd3},
		{0x3620,0x28},
		{0x3309,0x60},
		{0x331f,0x59},
		{0x3308,0x10},
		{0x320c,0x08},
		{0x320d,0x98},
		{0x320e,0x04},
		{0x320f,0x65},
		{0x3208,0x07},
		{0x3209,0x88},
		{0x320a,0x04},
		{0x320b,0x40},
		{0x3211,0x04},
		{0x3213,0x04},
		{0x3f00,0x07},
		{0x3f04,0x04},
		{0x3f05,0x28},
		{0x3802,0x01},
		{0x3235,0x08},
		{0x3236,0xc8},
		{0x303b,0x06},
		{0x3034,0x05},
		{0x3035,0x82},
		{0x33aa,0x10},
		{0x3630,0x1c},
		{0x3039,0x24},
		{0x303a,0x36},
		{0x3301,0x10},
		{0x3306,0x48},
		{0x3631,0x84},
		{0x3632,0x08},
		{0x3633,0x34},
		{0x3622,0xc6},
		{0x5780,0xff},
		
		{0x3d08, 0x03},
		{0x3640, 0x01},
		{0x3641, 0x01},
		{0x391c, 0x98}, // Blc…¡Œ Ã‚
		{0x0100,0x01},
};

// ExtClk: 27M MIPI_2Lane
static const XM_U16 gau16SnsInit_sc2235P_Mipi[][2] = {
	{0x0100,0x00},
	{0x3001,0xfe},
	{0x3018,0x33},
	{0x3031,0x0a},
	{0x3037,0x20},
	{0x3038,0xff},
	{0x3039,0x22},
	{0x303b,0x06},
	{0x303c,0x0e},
	{0x3200,0x00},
	{0x3201,0x00},
	{0x3202,0x00},
	{0x3203,0x00},
	{0x3204,0x07},
	{0x3205,0x8f},
	{0x3206,0x04},
	{0x3207,0x47},
	{0x3208,0x07},
	{0x3209,0x88},
	{0x320a,0x04},
	{0x320b,0x40},
	{0x320c,0x0a},
	{0x320d,0x50},
	{0x320e,0x04},
	{0x320f,0x65},
	{0x3211,0x04},
	{0x3213,0x04},
	{0x3222,0x29},
	{0x3235,0x08},
	{0x3236,0xc8},
	{0x3301,0x06},
	{0x3302,0x1f},
	{0x3303,0x20},
	{0x3306,0x48},
	{0x3308,0x10},
	{0x3309,0x60},
	{0x330b,0xd3},
	{0x330e,0x30},
	{0x3314,0x08},
	{0x331b,0x83},
	{0x331e,0x19},
	{0x331f,0x59},
	{0x3320,0x01},
	{0x3326,0x00},
	{0x3333,0x30},
	{0x335e,0x01},
	{0x335f,0x03},
	{0x3366,0x7c},
	{0x3367,0x08},
	{0x3368,0x04},
	{0x3369,0x00},
	{0x336a,0x00},
	{0x336b,0x00},
	{0x337c,0x04},
	{0x337d,0x06},
	{0x337f,0x03},
	{0x33a0,0x05},
	{0x33aa,0x10},
	{0x360f,0x01},
	{0x3620,0x28},
	{0x3621,0x28},
	{0x3622,0x06},
	{0x3624,0x08},
	{0x3625,0x02},
	{0x3630,0x1c},
	{0x3631,0x84},
	{0x3632,0x08},
	{0x3633,0x4f},
	{0x3635,0xa0},
	{0x3636,0x25},
	{0x3637,0x59},
	{0x3638,0x1f},
	{0x3639,0x09},
	{0x363a,0x9f},
	{0x363b,0x0b},
	{0x363c,0x05},
	{0x366e,0x08},
	{0x366f,0x2f},
	{0x3670,0x0c},
	{0x3671,0xc6},
	{0x3672,0x06},
	{0x3673,0x16},
	{0x3677,0x84},
	{0x3678,0x88},
	{0x3679,0x88},
	{0x367a,0x28},
	{0x367b,0x3f},
	{0x367e,0x08},
	{0x367f,0x28},
	{0x3690,0x34},
	{0x3691,0x11},
	{0x3692,0x42},
	{0x369c,0x08},
	{0x369d,0x28},
	{0x3802,0x01},
	{0x3901,0x02},
	{0x3902,0xC5},	// 0x45
	{0x3905,0x98},
	{0x3907,0x00},
	{0x3908,0x11},
	{0x391b,0x80},
	{0x3e00,0x00},
	{0x3e01,0x8c},
	{0x3e02,0x60},
	{0x3e03,0x0b},
	{0x3e06,0x00},
	{0x3e07,0x80},
	{0x3e08,0x03},
	{0x3e09,0x10},
	{0x3e1e,0x34},
	{0x3f00,0x07},
	{0x3f04,0x04},
	{0x3f05,0x28},
	{0x4603,0x00},
	{0x4827,0x48},
	{0x4837,0x35},
	{0x5000,0x06},
	{0x5780,0xff},
	{0x5781,0x04},
	{0x5785,0x18},
	
	{0x0100,0x01},

	{0xF5, 0xA5},		// SleepMask1
	{0x5A, 0x5F},		// SleepMask2
	{0x00, 0x64},		// 100ms
};

XM_U32 sensor_getlist_sc2235P(XM_U16 *pu16Num)
{
	if(gstSnsAttr.u8InputMode == SENSCONT_MIPI)
	{
		printf("sc2235p mipi_2lane @20181130\n");
		*pu16Num = sizeof(gau16SnsInit_sc2235P_Mipi)/sizeof(gau16SnsInit_sc2235P_Mipi[0]);
		return (XM_U32)gau16SnsInit_sc2235P_Mipi;
	}
	else
	{
		*pu16Num = sizeof(gau16SnsInit_sc2235P_DVP)/sizeof(gau16SnsInit_sc2235P_DVP[0]);
		return (XM_U32)gau16SnsInit_sc2235P_DVP;
	}
}

#endif
