#include "xm_type.h"
#include "xm_comm_isp.h"
#include "xm_comm_sns.h"
#include "xm_sns_ctrl.h"
#include "mpi_isp.h"
#include "mpi_ae.h"
#include "mpi_awb.h"
#include "xm_awb_comm.h"

#include "xm_print.h"
#include "XAx_cmos.h"

#define STATIC	static
extern XM_U8 gu8MaxShutterOfst;
extern const XM_U16 gau16GainTbl_SmatSns[64];
extern XM_U32 gau32AllGain;
extern void (*pfn_gainLogic)(XM_U32 u32AllGain);

extern XM_S32 cmos_set_mirror_flip_sc2235(XM_U8 u8Mirror,XM_U8 u8Flip);
extern void cmos_again_calc_table_sc2235(XM_U32 u32InTimes,AE_SENSOR_GAININFO_S *pstAeSnsGainInfo);
extern XM_VOID cmos_gain_calc_table_com(XM_U32 u32InTimes,AE_SENSOR_GAININFO_S *pstAeSnsGainInfo);
extern XM_VOID cmos_inttime_update_sc2235(XM_U32 u32IntTime);
extern XM_VOID cmos_gains_update_sc2235(XM_U32 u32Again, XM_U32 u32Dgain);



STATIC XM_VOID cmos_dgain_calc_table(XM_U32 u32InTimes,AE_SENSOR_GAININFO_S *pstAeSnsGainInfo)
{
	if(XM_NULL == pstAeSnsGainInfo)
	{
		return;
	}
	u32InTimes = u32InTimes/32 *2;
	if(u32InTimes < 1) u32InTimes = 1;
	pstAeSnsGainInfo->u32GainDb = u32InTimes;
	pstAeSnsGainInfo->u32SnsTimes = pstAeSnsGainInfo->u32GainDb*16;
	return;
}

const static XM_U8 gau8Logic_sc1235[3][3] = {
	//0x3631 0x3301 0x3633
	//AHD
	{0x84, 0x04, 0x2f},
	{0x88, 0x10, 0x23},
	{0x88, 0xb0, 0x43},
};

void gainLogic_sc1235(XM_U32 u32AllGain)
{
	static XM_U8 su8Idx = 0xFF;//[bit0~bit3]:Vstd   [bit4~bit7]:Agc
	XM_U8 u8Idx2;
//	XM_U8 u8Idx,u8Idx2;
//	if(gu8Fps==50)		u8Idx = 0;
//	else if(gu8Fps==60) 	u8Idx = 1;
//	else					u8Idx = 2;
	if(u32AllGain<32){
		u8Idx2 = 0;
	}
	else if(u32AllGain<64){
		u8Idx2 = 1;
	}
	else{
		u8Idx2 = 2;
	}
	if(((su8Idx>>4)&0x0F) != u8Idx2)
	{
		su8Idx = ((u8Idx2&0x0F)<<4);
		sensor_write_register(0x3812, 0x00);
		sensor_write_register(0x3631, (XM_U32)gau8Logic_sc1235[u8Idx2][0]);
		sensor_write_register(0x3301, (XM_U32)gau8Logic_sc1235[u8Idx2][1]);
		sensor_write_register(0x3633, (XM_U32)gau8Logic_sc1235[u8Idx2][2]);
		sensor_write_register(0x3812, 0x30);
	}
}

/* the function of sensor set fps */
STATIC XM_VOID cmos_fps_set(XM_U8 u8Fps, AE_SENSOR_DEFAULT_S *pstAeSnsDft)
{
	XM_U32 u32Pixs=1920;
#ifdef RES_960
	gu16FullLines = 1000;
	switch(u8Fps)
	{
		case 30:
			u32Pixs = 2700;
			break;
		case 25:
		default:
			u32Pixs = 2700;
			break;
	}	
#else
	gu16FullLines = HD720P_LINES;
	switch(u8Fps)
	{
		case 30:
			u32Pixs = 1600;
			break;
		case 25:
		default:
			u32Pixs = 1920;
			break;
	}		
#endif
	if(pstAeSnsDft != NULL) 
	{
		pstAeSnsDft->u32FullLinesStd = gu16FullLines;
		pstAeSnsDft->u32MaxIntTime = pstAeSnsDft->u32FullLinesStd-gu8MaxShutterOfst;
		pstAeSnsDft->u32LinesPer500ms = pstAeSnsDft->u32FullLinesStd * u8Fps / 2;
	}
	sensor_write_register(0x320c, (u32Pixs>>8)&0xFF);
	sensor_write_register(0x320d, u32Pixs&0xFF);

	u32Pixs=u32Pixs-36;
	sensor_write_register(0x3f04,(u32Pixs>>8)&0xFF);
	sensor_write_register(0x3f05,u32Pixs&0xFF);
	gu8Fps = u8Fps;
	if(pfn_gainLogic)
	{
		(*pfn_gainLogic)(gau32AllGain);
	}
	return;
}



/****************************************************************************
 * callback structure                                                       *
 ****************************************************************************/
XM_S32 cmos_init_ae_exp_function_sc1235(AE_SENSOR_EXP_FUNC_S *pstExpFuncs)
{
	pstExpFuncs->pfn_cmos_fps_set           = cmos_fps_set;
	pstExpFuncs->pfn_cmos_slow_framerate_set= NULL;    
	pstExpFuncs->pfn_cmos_inttime_update    = cmos_inttime_update_sc2235;
	pstExpFuncs->pfn_cmos_gains_update      = cmos_gains_update_sc2235;
	pstExpFuncs->pfn_cmos_again_calc_table  = cmos_again_calc_table_sc2235;
	pstExpFuncs->pfn_cmos_dgain_calc_table  = cmos_dgain_calc_table;
	pstExpFuncs->pfn_cmos_shut_calc_table = NULL;
	return 0;
}


#if(defined SOC_SYSTEM) || (defined SOC_ALIOS)
const ISP_CMOS_AGC_TABLE_S g_stIspAgcTable_sc1235 =
{
	/* bvalid */
	1,
	/* 100, 200, 400, 800, 1600, 3200, 6400, 12800; 100, 200, 400, 800, 1600, 3200, 6400, 12800 */
	//[0~7]:Normal						
	/* sharpen_D	H	*/
	{0x18,0x18,0x18,0x18,0x18,0x14,0x10,0x10,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04},
	
	/* sharpen_Ud M */
	{0x20,0x20,0x20,0x1C,0x1C,0x1A,0x18,0x18,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04},

	/* sharpen_Kd  */
	{0x31,0x30,0x30,0x2C,0x28,0x1C,0x18,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},
	
	/* snr_thresh 2DNr		*/
	{0x00,0x01,0x04,0x10,0x20,0x28,0x30,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40},

	/* snr_thresh 3DNr	 Tf	*/
	{0x04,0x06,0x0A,0x0E,0x12,0x15,0x17,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},

	/* snr_thresh 3DNr	 Sf	*/
	{0x00,0x00,0x00,0x00,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10},  

	/* DyDpc_thresh 		*/
	{0x00,0x00,0x00,0xA0,0xD0,0xD8,0xE0,0xE0,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
	
	/* saturation_strength */
	{0x92,0x92,0x92,0x7F,0x6E,0x56,0x32,0x2D,0x2D,0x20,0x20,0x20,0x20,0x20,0x20,0x20},
	
	/* Blc	*/
	{0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49},

	/*Y_Tran gamma*/ 
	{0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32},
};

const AE_SENSOR_DEFAULT_V2_S gstAeSnsDef_sc1235 = {
	2, HD720P_LINES-4,	// minInt   	maxInt
	1024,15872, 		// minAgain maxAgain
	16,64,				// minDgain 	maxDgain
	0xFFF,				// maxIspGain
	0x01010002,			// Update
	{700,700,700,700},
	0x00
};

const ISP_COLORMATRIX_AUTO_S g_stAwbCcm_sc1235 =
{
	5000,
	{
		0x0000,	362,	-98,	-8,
		0x0000,	-57,	414,	-101,
		0x0000,	18,	    -147,   385,
	},
	4000,
	{
		0x0000, 363, -114, 7,
		0x0000, -81, 390, -53,
		0x0000, 16, -186, 426
	},
	2800,
	{
		0x0000, 287,  6, -37,
		0x0000, -99, 415, -60,
		0x0000, -21, -239, 516
	}
};

const ISP_AWB_CALIBRATION_V2_S gstAwbCal_sc1235 = {
    {0, 0, 4096, 2493, 3730, 1843, 2098, 4096},
    {4096, 3554, 0, 0, 3067, 2481, 4096, 1204},
    {-1225, -4096, -1951, -4096, -4096, -4096, -3525, -3137},
    213,
    0, 1876, 0, 3297,
    {0, 994, 1282, 1626, 1736, 1881, 2145, 2158, 3297, 0, 0, 0, 0, 0, 0, 0},
    {2000, 2150, 2800, 4000, 4150, 5000, 6500, 7500, 12000, 0, 0, 0, 0, 0, 0, 0},
    {1381, 1024, 1370, 0}
};

static const XM_U16 gau16SnsInit_sc1235[][2] = {
#ifdef RES_960
	{0x0103, 0x01},
	{0x0100, 0x00},
	{0x3635, 0xa0},
	{0x3305, 0x00},
	{0x363a, 0x1f},
	{0x363b, 0x09},
	{0x33b5, 0x10},
	{0x4500, 0x59},
	{0x335c, 0x57},
	{0x3d08, 0x02},	// 0x00
	{0x3621, 0x28},
	{0x3303, 0x28},
	{0x333a, 0x0a},
	{0x3908, 0x11},
	{0x3366, 0x7c},
	{0x3e08, 0x03},
	{0x3e09, 0x10},
	{0x3636, 0x25},
	{0x3625, 0x01},
	{0x320c, 0x07},
	{0x320d, 0x08},
	{0x391e, 0x00},
	{0x3034, 0x05},
	{0x330a, 0x01},
	{0x3634, 0x21},
	{0x3e01, 0x3e},
	{0x3364, 0x05},
	{0x363c, 0x06},
	{0x3637, 0x0e},
	{0x335e, 0x01},
	{0x335f, 0x03},
	{0x337c, 0x04},
	{0x337d, 0x06},
	{0x33a0, 0x05},
	{0x3301, 0x05},
	{0x3302, 0xff},
	{0x3633, 0x2f},
	{0x330b, 0x6c},
	{0x3638, 0x0f},
	{0x3306, 0x68},
	{0x366e, 0x08},
	{0x366f, 0x2f},
	{0x3e23, 0x07},
	{0x3e24, 0x10},
	{0x331d, 0x0a},
	{0x333b, 0x00},
	{0x3357, 0x5a},
	{0x3309, 0xa8},
	{0x331f, 0x8d},
	{0x3321, 0x8f},
	{0x3631, 0x84},
	{0x3038, 0xff},
	{0x391b, 0x4d},
	{0x337f, 0x03},
	{0x3368, 0x02},
	{0x3369, 0x00},
	{0x336a, 0x00},
	{0x336b, 0x00},
	{0x3367, 0x08},
	{0x330e, 0x30},
	{0x3213, 0x02},
	{0x3802, 0x01},
	{0x3235, 0x03},
	{0x3236, 0xe6},
	{0x3208, 0x05},
	{0x3209, 0x0A},	// 0x08
	{0x320a, 0x03},
	{0x320b, 0xc8},
	{0x3211, 0x03},	// 0x04
	{0x3f00, 0x07},
	{0x3f04, 0x06},
	{0x3f05, 0xe4},
	{0x5780, 0xff},
	{0x5781, 0x04},
	{0x5785, 0x18},
	{0x3622, 0x06},
	{0x3630, 0x28},
	{0x3313, 0x05},
	{0x3639, 0x09},
	{0x3640, 0x03}, 	// 0x00
	#if 1// 36M
	{0x3039, 0x35},
	{0x303a, 0xA6},
	#else	// 27M
	{0x3039, 0x31},
	{0x303a, 0xC6},
	#endif
	{0x3641,0x02},
	{0x3D08,0x03},
	{0x0100, 0x01},
#else
	{0x0100,0x00},
	{0x3635,0xa0},
	{0x3305,0x00},
	{0x3639,0x0c},
	{0x363a,0x1f},
	{0x363b,0x09},
	{0x33b5,0x10},
	{0x4500,0x59},
	{0x335c,0x57},
	{0x3d08,0x00},
	{0x3621,0x28},
	{0x3303,0x28},
	{0x333a,0x0a},
	{0x3908,0x11},
	{0x3366,0x7c},
	{0x3e08,0x03},
	{0x3e09,0x10},
	{0x3636,0x25},
	{0x3625,0x01},
	{0x391e,0x00},
	{0x330a,0x01},
	{0x3634,0x21},
	{0x3364,0x05},
	{0x363c,0x06},
	{0x3637,0x0e},
	{0x335e,0x01},
	{0x335f,0x03},
	{0x337c,0x04},
	{0x337d,0x06},
	{0x33a0,0x05},
	{0x3301,0x05},
	{0x3302,0xff},
	{0x3633,0x2f},
	{0x330b,0x6c},
	{0x3630,0xa8},
	{0x3622,0x02},
	{0x3638,0x0f},
	{0x366e,0x08},
	{0x366f,0x2f},
	{0x3e23,0x07},
	{0x3e24,0x10},
	{0x331d,0x0a},
	{0x333b,0x00},
	{0x3357,0x5a},
	{0x3309,0xa8},
	{0x331f,0x8d},
	{0x3321,0x8f},
	{0x3631,0x84},
	{0x3038,0xff},
	{0x391b,0x4d},
	{0x3670,0x00},	//0x08
	{0x367e,0x07},
	{0x367f,0x0f},
	{0x3677,0x2f},
	{0x3678,0x23},
	{0x337f,0x03},
	{0x3368,0x02},
	{0x3369,0x00},
	{0x336a,0x00},
	{0x336b,0x00},
	{0x3367,0x08},
	{0x330e,0x30},
	{0x3213,0x02},
	{0x3802,0x01},
	{0x3235,0x02},
	{0x3236,0xec},
	{0x3679,0x43},
	{0x3208,0x05},
	{0x3209,0x08},
	{0x320a,0x02},
	{0x320b,0xd8},
	{0x3211,0x04},
	{0x320c,0x06},//1600
	{0x320d,0x40},
	{0x320e,0x02},
	{0x320f,0xee},//750
	{0x3202,0x00},
	{0x3203,0x78},
	{0x3206,0x03},
	{0x3207,0x57},
	{0x3039,0x25},
	#if 0 // FPGA   (ExtClk: 36M)
	{0x303a,0xd6},	// 0xc6
	{0x330b,0x3c},
	#else
	{0x303a,0xc6},
	#endif
	{0x3034,0x23},
	{0x3035,0xc2},
	{0x3306,0x50},
	{0x3e01,0x2e},
	{0x3e02,0x00},
	{0x3640,0x02},	// 0x00
	{0x3641,0x02},	// 0x00
	{0x3D08,0x03},	// 0x02
	{0x0100,0x01},//Stream Enable
#endif
};

XM_U32 sensor_getlist_sc1235(XM_U16 *pu16Num)
{
	*pu16Num = sizeof(gau16SnsInit_sc1235)/sizeof(gau16SnsInit_sc1235[0]);
	return (XM_U32)gau16SnsInit_sc1235;
}

#endif

