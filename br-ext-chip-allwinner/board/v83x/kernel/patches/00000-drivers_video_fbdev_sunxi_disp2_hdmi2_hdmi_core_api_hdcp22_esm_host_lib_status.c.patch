diff -drupN a/drivers/video/fbdev/sunxi/disp2/hdmi2/hdmi_core/api/hdcp22/esm_host_lib_status.c b/drivers/video/fbdev/sunxi/disp2/hdmi2/hdmi_core/api/hdcp22/esm_host_lib_status.c
--- a/drivers/video/fbdev/sunxi/disp2/hdmi2/hdmi_core/api/hdcp22/esm_host_lib_status.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/video/fbdev/sunxi/disp2/hdmi2/hdmi_core/api/hdcp22/esm_host_lib_status.c	2022-06-12 05:28:14.000000000 +0300
@@ -0,0 +1,133 @@
+/*
+ * Allwinner SoCs hdmi2.0 driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include "include/ESMHost.h"
+
+void boot_fail_check(esm_instance_t *esm)
+{
+	u32 reg = 0;
+
+	esm->driver->hpi_read(esm->driver->instance,
+				ESM_REG_AE_ERR_STAT0(HPI_HOST_OFF),
+				&reg);
+
+	pr_info("boot_fail_check 0x60:%x", reg);
+}
+
+
+ESM_STATUS ESM_GetStatusRegister(esm_instance_t *esm, esm_status_t *status,
+							uint8_t clear)
+{
+	ESM_STATUS err;
+	uint32_t reg0 = 0;
+	uint32_t clr = 0, clr1 = 0;
+
+	/*LOG_TRACE();*/
+	if (esm == 0)
+		return ESM_HL_NO_INSTANCE;
+
+	/* Read the status bitmask */
+	if (esm->driver->hpi_read(esm->driver->instance,
+					ESM_REG_HP_IRQ_STAT_MSG(HPI_HOST_OFF),
+					&reg0) != ESM_HL_SUCCESS) {
+		pr_info("HPI Read Failed %d", err);
+		return ESM_HL_DRIVER_HPI_READ_FAILED;
+	}
+
+	if (ESM_REG_HP_IRQ_BIT_SET(reg0, HP_IRQ_STAT_UPDATED_STAT_BIT)) {
+		if (esm->driver->hpi_read(esm->driver->instance,
+					ESM_REG_AE_ERR_STAT0(HPI_HOST_OFF),
+					&status->esm_exception) != ESM_HL_DRIVER_SUCCESS) {
+			pr_info("HPI Read Failed %d", err);
+			return ESM_HL_DRIVER_HPI_READ_FAILED;
+		}
+		/* Populate exceptions FIFO buffer */
+		esm_hostlib_put_exceptions(esm);
+		/* Save the last exception */
+		esm->esm_exception = status->esm_exception;
+		clr |= (1 << HP_IRQ_STAT_UPDATED_STAT_BIT);
+		clr1 |= (1 << HP_IRQ_STAT_UPDATED_STAT_BIT);
+	}
+
+	if (ESM_REG_HP_IRQ_BIT_SET(reg0, HP_IRQ_SYNC_LOST_STAT_BIT)) {
+		esm->esm_sync_lost = 1;
+		status->esm_sync_lost = 1;
+		clr |= (1 << HP_IRQ_SYNC_LOST_STAT_BIT);
+	} else {
+		esm->esm_sync_lost = 0;
+		status->esm_sync_lost = 0;
+	}
+
+	if (ESM_REG_HP_IRQ_BIT_SET(reg0, HP_IRQ_AUTH_PASS_STAT_BIT)) {
+		esm->esm_auth_pass = 1;
+		status->esm_auth_pass = 1;
+		clr |= (1 << HP_IRQ_AUTH_PASS_STAT_BIT);
+	} else {
+		esm->esm_auth_pass = 0;
+		status->esm_auth_pass = 0;
+	}
+
+	if (ESM_REG_HP_IRQ_BIT_SET(reg0, HP_IRQ_AUTH_FAIL_STAT_BIT)) {
+		esm->esm_auth_fail = 1;
+		status->esm_auth_fail = 1;
+		clr |= (1 << HP_IRQ_AUTH_FAIL_STAT_BIT);
+	} else {
+		esm->esm_auth_fail = 0;
+		status->esm_auth_fail = 0;
+	}
+
+
+	if (clear == 1) {
+		if (clr != 0) {
+			if (esm->driver->hpi_write(esm->driver->instance,
+					ESM_REG_HP_IRQ_STAT_MSG(HPI_HOST_OFF), clr) != ESM_HL_SUCCESS) {
+				pr_info("HPI Write Failed %d", err);
+				return ESM_HL_DRIVER_HPI_WRITE_FAILED;
+			}
+		}
+	} else {
+		if (clr1 != 0) {
+			if (esm->driver->hpi_write(esm->driver->instance,
+					ESM_REG_HP_IRQ_STAT_MSG(HPI_HOST_OFF), clr1) != ESM_HL_SUCCESS) {
+				pr_info("HPI Write Failed %d", err);
+				return ESM_HL_DRIVER_HPI_WRITE_FAILED;
+			}
+		}
+	}
+
+	return ESM_HL_SUCCESS;
+}
+
+/*This function returns the current state of the ESM and
+can be used to periodically poll the ESM. To receive immediate
+asynchronous ESM status notifications the #ESM_GetStatusRegister
+function is recommended.*/
+ESM_STATUS ESM_GetState(esm_instance_t *esm, uint32_t *State, esm_status_t *Status)
+{
+	ESM_STATUS err;
+
+	if (esm == NULL)
+		return ESM_HL_NO_INSTANCE;
+
+	*State = 0;
+	err = esm_hostlib_mb_cmd(esm, ESM_CMD_SYSTEM_GET_STATE_REQ, 0, 0,
+		ESM_CMD_SYSTEM_GET_STATE_RESP, 1, State, CMD_DEFAULT_TIMEOUT);
+	if (err != ESM_HL_SUCCESS) {
+		pr_info("MB Failed %d\n", err);
+		return ESM_HL_MB_FAILED;
+	}
+
+	err = ESM_GetStatusRegister(esm, Status, 1);
+	if (err != ESM_HL_SUCCESS) {
+		pr_info("HPI Read Failed %d\n", err);
+		return ESM_HL_DRIVER_HPI_READ_FAILED;
+	}
+
+	return ESM_HL_SUCCESS;
+}
