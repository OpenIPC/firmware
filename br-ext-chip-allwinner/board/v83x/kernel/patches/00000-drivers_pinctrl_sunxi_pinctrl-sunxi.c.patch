diff -drupN a/drivers/pinctrl/sunxi/pinctrl-sunxi.c b/drivers/pinctrl/sunxi/pinctrl-sunxi.c
--- a/drivers/pinctrl/sunxi/pinctrl-sunxi.c	2018-08-06 17:23:04.000000000 +0300
+++ b/drivers/pinctrl/sunxi/pinctrl-sunxi.c	2022-06-12 05:28:14.000000000 +0300
@@ -12,10 +12,10 @@
 
 #include <linux/io.h>
 #include <linux/clk.h>
-#include <linux/gpio/driver.h>
+#include <linux/gpio.h>
 #include <linux/irqdomain.h>
 #include <linux/irqchip/chained_irq.h>
-#include <linux/export.h>
+#include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_device.h>
@@ -26,9 +26,15 @@
 #include <linux/pinctrl/pinconf-generic.h>
 #include <linux/pinctrl/pinmux.h>
 #include <linux/platform_device.h>
+#include <linux/debugfs.h>
 #include <linux/slab.h>
+#include <linux/sunxi-gpio.h>
+#include <asm/uaccess.h>
+#include <linux/arisc/arisc.h>
 
 #include "../core.h"
+#include "../pinconf.h"
+#include "../../gpio/gpiolib.h"
 #include "pinctrl-sunxi.h"
 
 static struct irq_chip sunxi_pinctrl_edge_irq_chip;
@@ -68,6 +74,31 @@ sunxi_pinctrl_find_function_by_name(stru
 }
 
 static struct sunxi_desc_function *
+sunxi_pinctrl_desc_find_function_by_mulval(struct sunxi_pinctrl *pctl,
+					 const char *pin_name,
+					 const u32 mul_sel)
+{
+	int i;
+
+	for (i = 0; i < pctl->desc->npins; i++) {
+		const struct sunxi_desc_pin *pin = pctl->desc->pins + i;
+
+		if (!strcmp(pin->pin.name, pin_name)) {
+			struct sunxi_desc_function *func = pin->functions;
+
+			while (func->name) {
+				if (func->muxval == mul_sel)
+					return func;
+
+				func++;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static struct sunxi_desc_function *
 sunxi_pinctrl_desc_find_function_by_name(struct sunxi_pinctrl *pctl,
 					 const char *pin_name,
 					 const char *func_name)
@@ -145,6 +176,226 @@ static int sunxi_pctrl_get_group_pins(st
 	return 0;
 }
 
+static bool sunxi_pctrl_has_bias_prop(struct device_node *node)
+{
+	return	of_find_property(node, "allwinner,pull", NULL);
+}
+
+static bool sunxi_pctrl_has_drive_prop(struct device_node *node)
+{
+	return of_find_property(node, "allwinner,drive", NULL);
+}
+
+static bool sunxi_pctrl_has_data_prop(struct device_node *node)
+{
+	return of_find_property(node, "allwinner,data", NULL);
+}
+
+static int sunxi_pctrl_parse_bias_prop(struct device_node *node)
+{
+	u32 val;
+
+	/* And fall back to the old binding */
+	if (of_property_read_u32(node, "allwinner,pull", &val))
+		return -EINVAL;
+
+	switch (val) {
+	case SUNXI_PINCTRL_NO_PULL:
+		return PIN_CONFIG_BIAS_DISABLE;
+	case SUNXI_PINCTRL_PULL_UP:
+		return PIN_CONFIG_BIAS_PULL_UP;
+	case SUNXI_PINCTRL_PULL_DOWN:
+		return PIN_CONFIG_BIAS_PULL_DOWN;
+	case SYSCFG_PROP_DEFAULT_VAL:
+		return val;
+	}
+
+	return -EINVAL;
+}
+
+static int sunxi_pctrl_parse_data_prop(struct device_node *node)
+{
+	u32 val;
+
+	if (of_property_read_u32(node, "allwinner,data", &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 0:
+	case 1:
+	case SYSCFG_PROP_DEFAULT_VAL:
+		return val;
+	}
+
+	return -EINVAL;
+}
+
+static int sunxi_pctrl_parse_drive_prop(struct device_node *node)
+{
+	u32 val;
+
+	/* Try the new style binding */
+	if (!of_property_read_u32(node, "drive-strength", &val)) {
+		/* We can't go below 10mA ... */
+		if (val < 10)
+			return -EINVAL;
+
+		/* ... and only up to 40 mA ... */
+		if (val > 40)
+			val = 40;
+
+		/* by steps of 10 mA */
+		return rounddown(val, 10);
+	}
+
+	/* And then fall back to the old binding */
+	if (of_property_read_u32(node, "allwinner,drive", &val))
+		return -EINVAL;
+	switch (val) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		return (val + 1) * 10;
+	case SYSCFG_PROP_DEFAULT_VAL:
+		return SYSCFG_PROP_DEFAULT_VAL;
+	}
+
+	return -EINVAL;
+
+}
+
+static const char *sunxi_pctrl_parse_function_prop(struct device_node *node)
+{
+	const char *function;
+	int ret;
+
+	/* Try the generic binding */
+	ret = of_property_read_string(node, "function", &function);
+	if (!ret)
+		return function;
+
+	/* And fall back to our legacy one */
+	ret = of_property_read_string(node, "allwinner,function", &function);
+	if (!ret)
+		return function;
+
+	return NULL;
+}
+
+static int sunxi_pctrl_parse_muxsel_prop(struct device_node *node,
+								u32 *muxsel)
+{
+	int ret;
+
+	ret = of_property_read_u32(node, "muxsel", muxsel);
+	if (!ret)
+		return ret;
+
+	return of_property_read_u32(node, "allwinner,muxsel", muxsel) ;
+}
+
+static const char *sunxi_pctrl_find_pins_prop(struct device_node *node,
+					      int *npins)
+{
+	int count;
+
+	/* Try the generic binding */
+	count = of_property_count_strings(node, "pins");
+	if (count > 0) {
+		*npins = count;
+		return "pins";
+	}
+
+	/* And fall back to our legacy one */
+	count = of_property_count_strings(node, "allwinner,pins");
+	if (count > 0) {
+		*npins = count;
+		return "allwinner,pins";
+	}
+
+	return NULL;
+}
+
+
+static unsigned long *sunxi_pctrl_build_pin_config(struct device_node *node,
+						   unsigned int *len)
+{
+	unsigned long *pinconfig;
+	unsigned int configlen = 0, idx = 0;
+	int ret;
+
+	if (sunxi_pctrl_has_drive_prop(node))
+		configlen++;
+	if (sunxi_pctrl_has_bias_prop(node))
+		configlen++;
+	if (sunxi_pctrl_has_data_prop(node))
+		configlen++;
+
+	pinconfig = kcalloc(configlen, sizeof(*pinconfig), GFP_KERNEL);
+	/*
+	 * If we don't have any configuration, bail out
+	 */
+	if (!configlen)
+		return NULL;
+
+	pinconfig = kzalloc(configlen * sizeof(*pinconfig), GFP_KERNEL);
+	if (!pinconfig)
+		return ERR_PTR(-ENOMEM);
+
+	if (sunxi_pctrl_has_drive_prop(node)) {
+		int drive = sunxi_pctrl_parse_drive_prop(node);
+
+		if (drive == -EINVAL) {
+			pr_err("pinctrl-%s: parse drive prop failed!\n",
+								node->name);
+			pr_err("pinctrl-%s: parse drive prop failed!\n", node->name);
+			ret = drive;
+			goto err_free;
+		}
+
+		if (drive != SYSCFG_PROP_DEFAULT_VAL)
+			pinconfig[idx++] = pinconf_to_config_packed(
+					PIN_CONFIG_DRIVE_STRENGTH, drive);
+	}
+
+	if (sunxi_pctrl_has_data_prop(node)) {
+		int data = sunxi_pctrl_parse_data_prop(node);
+
+		if (data == -EINVAL) {
+			pr_err("pinctrl-%s: parse data prop failed!\n",
+								node->name);
+			ret = data;
+			goto err_free;
+		}
+
+		if (data != SYSCFG_PROP_DEFAULT_VAL)
+			pinconfig[idx++] =
+			pinconf_to_config_packed(PIN_CONFIG_OUTPUT, data);
+	}
+
+	if (sunxi_pctrl_has_bias_prop(node)) {
+		int pull = sunxi_pctrl_parse_bias_prop(node);
+
+		if (pull == -EINVAL) {
+			pr_err("pinctrl-%s: parse bias prop failed!\n",
+								node->name);
+			ret = pull;
+			goto err_free;
+		}
+
+		if (pull != SYSCFG_PROP_DEFAULT_VAL)
+			pinconfig[idx++] = pinconf_to_config_packed(pull, 0);
+	}
+
+	*len = configlen;
+	return pinconfig;
+
+err_free:
+	kfree(pinconfig);
+	return ERR_PTR(ret);
+}
+
 static int sunxi_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
 				      struct device_node *node,
 				      struct pinctrl_map **map,
@@ -153,97 +404,118 @@ static int sunxi_pctrl_dt_node_to_map(st
 	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
 	unsigned long *pinconfig;
 	struct property *prop;
-	const char *function;
+	struct sunxi_desc_function *func;
+	const char *expect_func, *pin_prop;
 	const char *group;
-	int ret, nmaps, i = 0;
-	u32 val;
+	int ret, npins, nmaps, configlen = 0, i = 0;
+	u32 muxsel;
 
 	*map = NULL;
 	*num_maps = 0;
 
-	ret = of_property_read_string(node, "allwinner,function", &function);
+	ret = sunxi_pctrl_parse_muxsel_prop(node, &muxsel);
 	if (ret) {
 		dev_err(pctl->dev,
-			"missing allwinner,function property in node %s\n",
+			"missing allwinner,muxsel property in node %s\n",
 			node->name);
 		return -EINVAL;
 	}
 
-	nmaps = of_property_count_strings(node, "allwinner,pins") * 2;
-	if (nmaps < 0) {
-		dev_err(pctl->dev,
-			"missing allwinner,pins property in node %s\n",
+	expect_func = sunxi_pctrl_parse_function_prop(node);
+	if (!expect_func) {
+		dev_err(pctl->dev, "missing expect_func property in node %s\n",
+			node->name);
+		return -EINVAL;
+	}
+
+
+	pin_prop = sunxi_pctrl_find_pins_prop(node, &npins);
+	if (!pin_prop) {
+		dev_err(pctl->dev, "missing pins property in node %s\n",
 			node->name);
 		return -EINVAL;
 	}
 
+	/*
+	 * We have two maps for each pin: one for the function, one
+	 * for the configuration (bias, strength, etc).
+	 *
+	 * We might be slightly overshooting, since we might not have
+	 * any configuration.
+	 */
+	nmaps = npins * 2;
 	*map = kmalloc(nmaps * sizeof(struct pinctrl_map), GFP_KERNEL);
 	if (!*map)
 		return -ENOMEM;
 
-	of_property_for_each_string(node, "allwinner,pins", prop, group) {
+	/*try the allwinner specific devicetree configuration first*/
+	pinconfig = sunxi_pctrl_build_pin_config(node, &configlen);
+	if (IS_ERR(pinconfig)) {
+		ret = PTR_ERR(pinconfig);
+		goto err_free_map;
+	}
+	/*then try the generic devicetree configuration */
+	if (!pinconfig) {
+		ret = pinconf_generic_parse_dt_config(node, pctldev, &pinconfig,
+						&configlen);
+		if (ret)
+			return ret;
+	}
+
+	of_property_for_each_string(node, pin_prop, prop, group) {
 		struct sunxi_pinctrl_group *grp =
 			sunxi_pinctrl_find_group_by_name(pctl, group);
-		int j = 0, configlen = 0;
 
 		if (!grp) {
 			dev_err(pctl->dev, "unknown pin %s", group);
 			continue;
 		}
-
-		if (!sunxi_pinctrl_desc_find_function_by_name(pctl,
-							      grp->name,
-							      function)) {
-			dev_err(pctl->dev, "unsupported function %s on pin %s",
-				function, group);
+		func = sunxi_pinctrl_desc_find_function_by_mulval(pctl,
+							grp->name,
+							muxsel);
+		if (!func) {
+			dev_err(pctl->dev, "can not get function on pin %s",
+				group);
 			continue;
 		}
+		/*ignore io_disabled func name*/
+		if (strcmp(func->name, expect_func) &&
+			 (strcmp(func->name, "io_disabled")))
+			dev_warn(pctl->dev,
+			"expect_func as:%s, but muxsel(%d) is func:%s\n",
+			expect_func, muxsel, func->name);
 
 		(*map)[i].type = PIN_MAP_TYPE_MUX_GROUP;
 		(*map)[i].data.mux.group = group;
-		(*map)[i].data.mux.function = function;
+		(*map)[i].data.mux.function = func->name;
 
 		i++;
 
-		(*map)[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;
-		(*map)[i].data.configs.group_or_pin = group;
-
-		if (of_find_property(node, "allwinner,drive", NULL))
-			configlen++;
-		if (of_find_property(node, "allwinner,pull", NULL))
-			configlen++;
-
-		pinconfig = kzalloc(configlen * sizeof(*pinconfig), GFP_KERNEL);
-		if (!pinconfig) {
-			kfree(*map);
-			return -ENOMEM;
-		}
-
-		if (!of_property_read_u32(node, "allwinner,drive", &val)) {
-			u16 strength = (val + 1) * 10;
-			pinconfig[j++] =
-				pinconf_to_config_packed(PIN_CONFIG_DRIVE_STRENGTH,
-							 strength);
-		}
-
-		if (!of_property_read_u32(node, "allwinner,pull", &val)) {
-			enum pin_config_param pull = PIN_CONFIG_END;
-			if (val == 1)
-				pull = PIN_CONFIG_BIAS_PULL_UP;
-			else if (val == 2)
-				pull = PIN_CONFIG_BIAS_PULL_DOWN;
-			pinconfig[j++] = pinconf_to_config_packed(pull, 0);
+		if (pinconfig) {
+			(*map)[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;
+			(*map)[i].data.configs.group_or_pin = group;
+			(*map)[i].data.configs.configs = pinconfig;
+			(*map)[i].data.configs.num_configs = configlen;
+			i++;
 		}
-
-		(*map)[i].data.configs.configs = pinconfig;
-		(*map)[i].data.configs.num_configs = configlen;
-
-		i++;
 	}
 
-	*num_maps = nmaps;
+	*num_maps = i;
+
+	/*
+	 * We know have the number of maps we need, we can resize our
+	 * map array
+	 */
+	*map = krealloc(*map, i * sizeof(struct pinctrl_map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
 
 	return 0;
+
+err_free_map:
+	kfree(*map);
+	*map = NULL;
+	return ret;
 }
 
 static void sunxi_pctrl_dt_free_map(struct pinctrl_dev *pctldev,
@@ -252,11 +524,20 @@ static void sunxi_pctrl_dt_free_map(stru
 {
 	int i;
 
-	for (i = 0; i < num_maps; i++) {
-		if (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)
-			kfree(map[i].data.configs.configs);
+	/* pin config is never in the first map */
+	for (i = 1; i < num_maps; i++) {
+		if (map[i].type != PIN_MAP_TYPE_CONFIGS_GROUP)
+			continue;
+
+		/*
+		 * All the maps share the same pin config,
+		 * free only the first one we find.
+		 */
+		kfree(map[i].data.configs.configs);
+		break;
 	}
 
+
 	kfree(map);
 }
 
@@ -268,84 +549,6 @@ static const struct pinctrl_ops sunxi_pc
 	.get_group_pins		= sunxi_pctrl_get_group_pins,
 };
 
-static int sunxi_pconf_group_get(struct pinctrl_dev *pctldev,
-				 unsigned group,
-				 unsigned long *config)
-{
-	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
-
-	*config = pctl->groups[group].config;
-
-	return 0;
-}
-
-static int sunxi_pconf_group_set(struct pinctrl_dev *pctldev,
-				 unsigned group,
-				 unsigned long *configs,
-				 unsigned num_configs)
-{
-	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
-	struct sunxi_pinctrl_group *g = &pctl->groups[group];
-	unsigned long flags;
-	unsigned pin = g->pin - pctl->desc->pin_base;
-	u32 val, mask;
-	u16 strength;
-	u8 dlevel;
-	int i;
-
-	spin_lock_irqsave(&pctl->lock, flags);
-
-	for (i = 0; i < num_configs; i++) {
-		switch (pinconf_to_config_param(configs[i])) {
-		case PIN_CONFIG_DRIVE_STRENGTH:
-			strength = pinconf_to_config_argument(configs[i]);
-			if (strength > 40) {
-				spin_unlock_irqrestore(&pctl->lock, flags);
-				return -EINVAL;
-			}
-			/*
-			 * We convert from mA to what the register expects:
-			 *   0: 10mA
-			 *   1: 20mA
-			 *   2: 30mA
-			 *   3: 40mA
-			 */
-			dlevel = strength / 10 - 1;
-			val = readl(pctl->membase + sunxi_dlevel_reg(pin));
-			mask = DLEVEL_PINS_MASK << sunxi_dlevel_offset(pin);
-			writel((val & ~mask)
-				| dlevel << sunxi_dlevel_offset(pin),
-				pctl->membase + sunxi_dlevel_reg(pin));
-			break;
-		case PIN_CONFIG_BIAS_PULL_UP:
-			val = readl(pctl->membase + sunxi_pull_reg(pin));
-			mask = PULL_PINS_MASK << sunxi_pull_offset(pin);
-			writel((val & ~mask) | 1 << sunxi_pull_offset(pin),
-				pctl->membase + sunxi_pull_reg(pin));
-			break;
-		case PIN_CONFIG_BIAS_PULL_DOWN:
-			val = readl(pctl->membase + sunxi_pull_reg(pin));
-			mask = PULL_PINS_MASK << sunxi_pull_offset(pin);
-			writel((val & ~mask) | 2 << sunxi_pull_offset(pin),
-				pctl->membase + sunxi_pull_reg(pin));
-			break;
-		default:
-			break;
-		}
-		/* cache the config value */
-		g->config = configs[i];
-	} /* for each config */
-
-	spin_unlock_irqrestore(&pctl->lock, flags);
-
-	return 0;
-}
-
-static const struct pinconf_ops sunxi_pconf_ops = {
-	.pin_config_group_get	= sunxi_pconf_group_get,
-	.pin_config_group_set	= sunxi_pconf_group_set,
-};
-
 static int sunxi_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)
 {
 	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
@@ -382,7 +585,7 @@ static void sunxi_pmx_set(struct pinctrl
 	unsigned long flags;
 	u32 val, mask;
 
-	spin_lock_irqsave(&pctl->lock, flags);
+	raw_spin_lock_irqsave(&pctl->lock, flags);
 
 	pin -= pctl->desc->pin_base;
 	val = readl(pctl->membase + sunxi_mux_reg(pin));
@@ -390,7 +593,7 @@ static void sunxi_pmx_set(struct pinctrl
 	writel((val & ~mask) | config << sunxi_mux_offset(pin),
 		pctl->membase + sunxi_mux_reg(pin));
 
-	spin_unlock_irqrestore(&pctl->lock, flags);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
 }
 
 static int sunxi_pmx_set_mux(struct pinctrl_dev *pctldev,
@@ -437,51 +640,342 @@ sunxi_pmx_gpio_set_direction(struct pinc
 	return 0;
 }
 
+static void sunxi_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
+				struct pinctrl_gpio_range *range,
+				unsigned offset)
+{
+	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sunxi_desc_function *desc;
+
+	desc = sunxi_pinctrl_desc_find_function_by_pin(pctl, offset, "io_disabled");
+	if (!desc)
+		return;
+
+	sunxi_pmx_set(pctldev, offset, desc->muxval);
+}
+
 static const struct pinmux_ops sunxi_pmx_ops = {
 	.get_functions_count	= sunxi_pmx_get_funcs_cnt,
 	.get_function_name	= sunxi_pmx_get_func_name,
 	.get_function_groups	= sunxi_pmx_get_func_groups,
 	.set_mux		= sunxi_pmx_set_mux,
 	.gpio_set_direction	= sunxi_pmx_gpio_set_direction,
+	.gpio_disable_free	= sunxi_pmx_gpio_disable_free,
+};
+
+static int sunxi_pconf_reg(unsigned pin, enum pin_config_param param,
+			   u32 *offset, u32 *shift, u32 *mask)
+{
+	switch (param) {
+	case PIN_CONFIG_DRIVE_STRENGTH:
+	case SUNXI_PINCFG_TYPE_DRV:
+		*offset = sunxi_dlevel_reg(pin);
+		*shift = sunxi_dlevel_offset(pin);
+		*mask = DLEVEL_PINS_MASK;
+		break;
+
+	case PIN_CONFIG_BIAS_PULL_UP:
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+	case PIN_CONFIG_BIAS_DISABLE:
+	case SUNXI_PINCFG_TYPE_PUD:
+		*offset = sunxi_pull_reg(pin);
+		*shift = sunxi_pull_offset(pin);
+		*mask = PULL_PINS_MASK;
+		break;
+	case SUNXI_PINCFG_TYPE_DAT:
+	case PIN_CONFIG_OUTPUT:
+		*offset = sunxi_data_reg(pin);
+		*shift = sunxi_data_offset(pin);
+		*mask = DATA_PINS_MASK;
+		break;
+	case SUNXI_PINCFG_TYPE_FUNC:
+	case PIN_CONFIG_INPUT_ENABLE:
+		*offset = sunxi_mux_reg(pin);
+		*shift = sunxi_mux_offset(pin);
+		*mask = MUX_PINS_MASK;
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static int sunxi_pconf_get(struct pinctrl_dev *pctldev,
+			     unsigned pin,
+			     unsigned long *config)
+{
+	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	enum pin_config_param param = pinconf_to_config_param(*config);
+	unsigned long flags;
+	u32 offset, shift, mask, val;
+	u16 arg;
+	int ret = 0;
+
+	pin -= pctl->desc->pin_base;
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+
+	ret = sunxi_pconf_reg(pin, param, &offset, &shift, &mask);
+	if (ret < 0) {
+		raw_spin_unlock_irqrestore(&pctl->lock, flags);
+		return ret;
+	}
+
+	val = (readl(pctl->membase + offset) >> shift) & mask;
+
+	switch (param) {
+	/* sunxi platform specified config type */
+	case SUNXI_PINCFG_TYPE_DRV:
+	case SUNXI_PINCFG_TYPE_PUD:
+	case SUNXI_PINCFG_TYPE_DAT:
+	case SUNXI_PINCFG_TYPE_FUNC:
+		arg = val;
+		break;
+	/* pinctrl generic config type */
+	case PIN_CONFIG_DRIVE_STRENGTH:
+		arg = (val + 1) * 10;
+		break;
+	case PIN_CONFIG_BIAS_PULL_UP:
+		if (val != SUNXI_PINCTRL_PULL_UP)
+			ret = -EINVAL;
+		arg = 1; /* hardware is weak pull-up */
+		break;
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		if (val != SUNXI_PINCTRL_PULL_DOWN)
+			ret = -EINVAL;
+		arg = 1; /* hardware is weak pull-down */
+		break;
+
+	case PIN_CONFIG_BIAS_DISABLE:
+		if (val != SUNXI_PINCTRL_NO_PULL)
+			ret = -EINVAL;
+		arg = 0;
+		break;
+	default:
+		pr_debug("invalid sunxi pconf type for get\n");
+		ret = -EINVAL;
+	}
+
+	if (!ret)
+		*config = pinconf_to_config_packed(param, arg);
+
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return ret;
+}
+
+static int sunxi_pconf_set(struct pinctrl_dev *pctldev,
+			     unsigned pin,
+			     unsigned long *pin_config,
+			     unsigned num_configs)
+{
+	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	unsigned long config = (unsigned long)pin_config;
+	unsigned long flags;
+	u32 offset, shift, mask, reg;
+	u32 arg, val;
+	int ret;
+	enum pin_config_param param;
+
+	pin = pin - pctl->desc->pin_base;
+
+	param = pinconf_to_config_param(config);
+	arg = pinconf_to_config_argument(config);
+	ret = sunxi_pconf_reg(pin, param, &offset, &shift, &mask);
+	if (ret < 0)
+		return 0;
+	switch (param) {
+	case SUNXI_PINCFG_TYPE_DRV:
+		val = arg;
+		break;
+	case SUNXI_PINCFG_TYPE_PUD:
+		val = arg;
+		break;
+
+	case SUNXI_PINCFG_TYPE_DAT:
+		val = arg;
+		break;
+	case SUNXI_PINCFG_TYPE_FUNC:
+		val = arg;
+		break;
+	case PIN_CONFIG_DRIVE_STRENGTH:
+		if (arg < 10 || arg > 40)
+			return -EINVAL;
+		/*
+		 * We convert from mA to what the register expects:
+		 *   0: 10mA
+		 *   1: 20mA
+		 *   2: 30mA
+		 *   3: 40mA
+		 */
+		val = arg / 10 - 1;
+		break;
+	case PIN_CONFIG_BIAS_DISABLE:
+		val = 0;
+		break;
+	case PIN_CONFIG_BIAS_PULL_UP:
+		val = 1;
+		break;
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		val = 2;
+		break;
+	case PIN_CONFIG_INPUT_ENABLE:
+		/*input muxsel is 0, output is 1*/
+		val = !arg;
+		break;
+	case PIN_CONFIG_OUTPUT:
+		val = arg;
+		break;
+	default:
+		pr_debug("invalid sunxi pconf type for set\n");
+		return -EINVAL;
+	}
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	reg = readl(pctl->membase + offset);
+	reg &= ~(mask << shift);
+	writel(reg | val << shift, pctl->membase + offset);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
+}
+
+static int sunxi_pconf_group_get(struct pinctrl_dev *pctldev,
+				 unsigned group,
+				 unsigned long *config)
+{
+	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sunxi_pinctrl_group *g = &pctl->groups[group];
+	/* We only support 1 pin per group. Chain it to the pin callback */
+	return sunxi_pconf_get(pctldev, g->pin, config);
+}
+
+static int sunxi_pconf_group_set(struct pinctrl_dev *pctldev,
+				 unsigned group,
+				 unsigned long *configs,
+				 unsigned num_configs)
+{
+	struct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	struct sunxi_pinctrl_group *g = &pctl->groups[group];
+	unsigned pin = g->pin - pctl->desc->pin_base;
+	int i;
+
+	for (i = 0; i < num_configs; i++) {
+		enum pin_config_param param;
+		unsigned long flags;
+		u32 offset, shift, mask, reg;
+		u32 arg, val;
+		int ret;
+
+		param = pinconf_to_config_param(configs[i]);
+		arg = pinconf_to_config_argument(configs[i]);
+
+		ret = sunxi_pconf_reg(pin, param, &offset, &shift, &mask);
+		/*In sunxi platform, if the pin property is set 'default' by
+		 * sys_config,the param and arg will be zero, and then
+		 * sunxi_pconf_reg() will return -ENOTSUPP, we didn't handle
+		 * this fault before we abondon the old configurate ways by
+		 * sys_config, so return  0 now*/
+		if (ret < 0)
+			return 0;
+
+		switch (param) {
+		case PIN_CONFIG_DRIVE_STRENGTH:
+			if (arg < 10 || arg > 40)
+				return -EINVAL;
+			/*
+			 * We convert from mA to what the register expects:
+			 *   0: 10mA
+			 *   1: 20mA
+			 *   2: 30mA
+			 *   3: 40mA
+			 */
+			val = arg / 10 - 1;
+			break;
+		case PIN_CONFIG_BIAS_DISABLE:
+			val = 0;
+			break;
+		case PIN_CONFIG_BIAS_PULL_UP:
+			val = 1;
+			break;
+		case PIN_CONFIG_BIAS_PULL_DOWN:
+			val = 2;
+			break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			sunxi_pmx_gpio_set_direction(pctldev, NULL, pin,
+								true);
+			return 0;
+		case PIN_CONFIG_OUTPUT:
+			sunxi_pmx_gpio_set_direction(pctldev, NULL, pin,
+								false);
+			val = arg;
+			break;
+		default:
+			/* sunxi_pconf_reg should catch anything unsupported */
+			WARN_ON(1);
+			return -ENOTSUPP;
+		}
+		/* cache the config value */
+		g->config = configs[i];
+		raw_spin_lock_irqsave(&pctl->lock, flags);
+		reg = readl(pctl->membase + offset);
+		reg &= ~(mask << shift);
+		writel(reg | val << shift, pctl->membase + offset);
+		raw_spin_unlock_irqrestore(&pctl->lock, flags);
+	} /* for each config */
+
+	return 0;
+}
+
+static const struct pinconf_ops sunxi_pconf_ops = {
+	.is_generic		= true,
+	.pin_config_get	= sunxi_pconf_get,
+	.pin_config_set	= sunxi_pconf_set,
+	.pin_config_group_get	= sunxi_pconf_group_get,
+	.pin_config_group_set	= sunxi_pconf_group_set,
 };
 
 static int sunxi_pinctrl_gpio_direction_input(struct gpio_chip *chip,
 					unsigned offset)
 {
-	return pinctrl_gpio_direction_input(chip->base + offset);
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(chip->parent);
+	u32 pin = pctl->desc->pin_base + offset;
+
+	sunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_INPUT);
+
+	return 0;
 }
 
 static int sunxi_pinctrl_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
-	struct sunxi_pinctrl *pctl = gpiochip_get_data(chip);
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(chip->parent);
 	u32 reg = sunxi_data_reg(offset);
 	u8 index = sunxi_data_offset(offset);
-	bool set_mux = pctl->desc->irq_read_needs_mux &&
-		gpiochip_line_is_irq(chip, offset);
-	u32 pin = offset + chip->base;
+	u32 set_mux = pctl->desc->irq_read_needs_mux &&
+			test_bit(FLAG_USED_AS_IRQ, &chip->gpiodev->descs[offset].flags);
 	u32 val;
 
 	if (set_mux)
-		sunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_INPUT);
+		sunxi_pmx_set(pctl->pctl_dev, offset, SUN4I_FUNC_INPUT);
 
 	val = (readl(pctl->membase + reg) >> index) & DATA_PINS_MASK;
 
 	if (set_mux)
-		sunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_IRQ);
+		sunxi_pmx_set(pctl->pctl_dev, offset, SUN4I_FUNC_IRQ);
 
-	return !!val;
+	return val;
 }
 
 static void sunxi_pinctrl_gpio_set(struct gpio_chip *chip,
 				unsigned offset, int value)
 {
-	struct sunxi_pinctrl *pctl = gpiochip_get_data(chip);
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(chip->parent);
 	u32 reg = sunxi_data_reg(offset);
 	u8 index = sunxi_data_offset(offset);
 	unsigned long flags;
 	u32 regval;
 
-	spin_lock_irqsave(&pctl->lock, flags);
+	raw_spin_lock_irqsave(&pctl->lock, flags);
 
 	regval = readl(pctl->membase + reg);
 
@@ -492,37 +986,89 @@ static void sunxi_pinctrl_gpio_set(struc
 
 	writel(regval, pctl->membase + reg);
 
-	spin_unlock_irqrestore(&pctl->lock, flags);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
 }
 
 static int sunxi_pinctrl_gpio_direction_output(struct gpio_chip *chip,
 					unsigned offset, int value)
 {
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(chip->parent);
+	u32 pin = pctl->desc->pin_base + offset;
+
 	sunxi_pinctrl_gpio_set(chip, offset, value);
-	return pinctrl_gpio_direction_output(chip->base + offset);
+	sunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_OUTPUT);
+
+	return 0;
+}
+
+static int sunxi_pinctrl_gpio_set_debounce(struct gpio_chip *chip,
+					unsigned offset, unsigned value)
+{
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(chip->parent);
+	unsigned pinnum = pctl->desc->pin_base + offset;
+	unsigned bank_base;
+	struct sunxi_desc_function *desc;
+	u32 reg, reg_val;
+	unsigned int val_clk_per_scale;
+	unsigned int val_clk_select;
+	unsigned long flags;
+
+	if (offset >= chip->ngpio)
+		return -ENXIO;
+
+	desc = sunxi_pinctrl_desc_find_function_by_pin(pctl, pinnum, "irq");
+	if (!desc)
+		return -EINVAL;
+
+	bank_base = pctl->desc->irq_bank_base[desc->irqbank];
+	reg = sunxi_irq_debounce_reg_from_bank(desc->irqbank, bank_base);
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	reg_val = readl(pctl->membase + reg);
+	val_clk_select = value & 1;
+	val_clk_per_scale = (value >> 4) & 0x07;
+
+	/*set debounce pio interrupt clock select */
+	reg_val &= ~(1 << 0);
+	reg_val |= val_clk_select;
+
+	/* set debounce clock pre scale */
+	reg_val &= ~(7 << 4);
+	reg_val |= val_clk_per_scale << 4;
+	writel(reg_val, pctl->membase + reg);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
 }
 
 static int sunxi_pinctrl_gpio_of_xlate(struct gpio_chip *gc,
 				const struct of_phandle_args *gpiospec,
 				u32 *flags)
 {
+	struct gpio_config *config;
 	int pin, base;
 
 	base = PINS_PER_BANK * gpiospec->args[0];
 	pin = base + gpiospec->args[1];
-
+	pin = pin - gc->base;
 	if (pin > gc->ngpio)
 		return -EINVAL;
 
-	if (flags)
-		*flags = gpiospec->args[2];
+	if (flags) {
+		config = (struct gpio_config *)flags;
+		config->gpio = base + gpiospec->args[1];
+		config->mul_sel = gpiospec->args[2];
+		config->pull = gpiospec->args[3];
+		config->drv_level = gpiospec->args[4];
+		config->data = gpiospec->args[5];
+	}
 
 	return pin;
 }
 
 static int sunxi_pinctrl_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
-	struct sunxi_pinctrl *pctl = gpiochip_get_data(chip);
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(chip->parent);
 	struct sunxi_desc_function *desc;
 	unsigned pinnum = pctl->desc->pin_base + offset;
 	unsigned irqnum;
@@ -546,21 +1092,12 @@ static int sunxi_pinctrl_irq_request_res
 {
 	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
 	struct sunxi_desc_function *func;
-	int ret;
 
 	func = sunxi_pinctrl_desc_find_function_by_pin(pctl,
 					pctl->irq_array[d->hwirq], "irq");
 	if (!func)
 		return -EINVAL;
 
-	ret = gpiochip_lock_as_irq(pctl->chip,
-			pctl->irq_array[d->hwirq] - pctl->desc->pin_base);
-	if (ret) {
-		dev_err(pctl->dev, "unable to lock HW IRQ %lu for IRQ\n",
-			irqd_to_hwirq(d));
-		return ret;
-	}
-
 	/* Change muxing to INT mode */
 	sunxi_pmx_set(pctl->pctl_dev, pctl->irq_array[d->hwirq], func->muxval);
 
@@ -570,15 +1107,22 @@ static int sunxi_pinctrl_irq_request_res
 static void sunxi_pinctrl_irq_release_resources(struct irq_data *d)
 {
 	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
+	struct sunxi_desc_function *func;
 
-	gpiochip_unlock_as_irq(pctl->chip,
-			      pctl->irq_array[d->hwirq] - pctl->desc->pin_base);
+	func = sunxi_pinctrl_desc_find_function_by_pin(pctl,
+					pctl->irq_array[d->hwirq], "io_disabled");
+	if (!func)
+		return;
+
+	/* Change muxing to io_disabled mode */
+	sunxi_pmx_set(pctl->pctl_dev, pctl->irq_array[d->hwirq], func->muxval);
 }
 
 static int sunxi_pinctrl_irq_set_type(struct irq_data *d, unsigned int type)
 {
 	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
-	u32 reg = sunxi_irq_cfg_reg(d->hwirq, pctl->desc->irq_bank_base);
+	unsigned bank_base = pctl->desc->irq_bank_base[d->hwirq/IRQ_PER_BANK];
+	u32 reg = sunxi_irq_cfg_reg(d->hwirq, bank_base);
 	u8 index = sunxi_irq_cfg_offset(d->hwirq);
 	unsigned long flags;
 	u32 regval;
@@ -604,7 +1148,7 @@ static int sunxi_pinctrl_irq_set_type(st
 		return -EINVAL;
 	}
 
-	spin_lock_irqsave(&pctl->lock, flags);
+	raw_spin_lock_irqsave(&pctl->lock, flags);
 
 	if (type & IRQ_TYPE_LEVEL_MASK)
 		irq_set_chip_handler_name_locked(d, &sunxi_pinctrl_level_irq_chip,
@@ -617,7 +1161,7 @@ static int sunxi_pinctrl_irq_set_type(st
 	regval &= ~(IRQ_CFG_IRQ_MASK << index);
 	writel(regval | (mode << index), pctl->membase + reg);
 
-	spin_unlock_irqrestore(&pctl->lock, flags);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
 
 	return 0;
 }
@@ -625,8 +1169,8 @@ static int sunxi_pinctrl_irq_set_type(st
 static void sunxi_pinctrl_irq_ack(struct irq_data *d)
 {
 	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
-	u32 status_reg = sunxi_irq_status_reg(d->hwirq,
-					      pctl->desc->irq_bank_base);
+	unsigned bank_base = pctl->desc->irq_bank_base[d->hwirq/IRQ_PER_BANK];
+	u32 status_reg = sunxi_irq_status_reg(d->hwirq, bank_base);
 	u8 status_idx = sunxi_irq_status_offset(d->hwirq);
 
 	/* Clear the IRQ */
@@ -636,35 +1180,37 @@ static void sunxi_pinctrl_irq_ack(struct
 static void sunxi_pinctrl_irq_mask(struct irq_data *d)
 {
 	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
-	u32 reg = sunxi_irq_ctrl_reg(d->hwirq, pctl->desc->irq_bank_base);
+	unsigned bank_base = pctl->desc->irq_bank_base[d->hwirq/IRQ_PER_BANK];
+	u32 reg = sunxi_irq_ctrl_reg(d->hwirq, bank_base);
 	u8 idx = sunxi_irq_ctrl_offset(d->hwirq);
 	unsigned long flags;
 	u32 val;
 
-	spin_lock_irqsave(&pctl->lock, flags);
+	raw_spin_lock_irqsave(&pctl->lock, flags);
 
 	/* Mask the IRQ */
 	val = readl(pctl->membase + reg);
 	writel(val & ~(1 << idx), pctl->membase + reg);
 
-	spin_unlock_irqrestore(&pctl->lock, flags);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
 }
 
 static void sunxi_pinctrl_irq_unmask(struct irq_data *d)
 {
 	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
-	u32 reg = sunxi_irq_ctrl_reg(d->hwirq, pctl->desc->irq_bank_base);
+	unsigned bank_base = pctl->desc->irq_bank_base[d->hwirq/IRQ_PER_BANK];
+	u32 reg = sunxi_irq_ctrl_reg(d->hwirq, bank_base);
 	u8 idx = sunxi_irq_ctrl_offset(d->hwirq);
 	unsigned long flags;
 	u32 val;
 
-	spin_lock_irqsave(&pctl->lock, flags);
+	raw_spin_lock_irqsave(&pctl->lock, flags);
 
 	/* Unmask the IRQ */
 	val = readl(pctl->membase + reg);
 	writel(val | (1 << idx), pctl->membase + reg);
 
-	spin_unlock_irqrestore(&pctl->lock, flags);
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
 }
 
 static void sunxi_pinctrl_irq_ack_unmask(struct irq_data *d)
@@ -673,6 +1219,159 @@ static void sunxi_pinctrl_irq_ack_unmask
 	sunxi_pinctrl_irq_unmask(d);
 }
 
+static int sunxi_pinctrl_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);
+	unsigned long bank = d->hwirq / PINS_PER_BANK;
+	unsigned long idx = d->hwirq % PINS_PER_BANK;
+	struct irq_data *bank_irq_d = irq_get_irq_data(pctl->irq[bank]);
+
+
+	if (on) {
+		pctl->wake_mask[bank] |= BIT(idx);
+#ifndef CONFIG_ARCH_SUN8IW8P1
+		arisc_set_wakeup_source(SET_SEC_WAKEUP_SOURCE(bank_irq_d->hwirq,
+							d->hwirq));
+#endif
+	} else {
+		pctl->wake_mask[bank] &= ~BIT(idx);
+#ifndef CONFIG_ARCH_SUN8IW8P1
+		arisc_clear_wakeup_source(SET_SEC_WAKEUP_SOURCE(bank_irq_d->hwirq,
+							d->hwirq));
+#endif
+	}
+
+	pctl->wake_debounce[bank] = 0;
+
+	return 0;
+}
+
+static int sunxi_pinctrl_get_intc_mask(struct sunxi_pinctrl *pctl, u32 *mask,
+				       u32 (*func)(u8, unsigned))
+{
+	u8 bank;
+	unsigned bank_base;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	for (bank = 0; bank < pctl->desc->irq_banks; bank++) {
+		bank_base = pctl->desc->irq_bank_base[bank];
+		mask[bank] = readl(pctl->membase + (*func)(bank, bank_base));
+	}
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
+}
+
+static int sunxi_pinctrl_set_intc_mask(struct sunxi_pinctrl *pctl, u32 *mask,
+				       u32 (*func)(u8, unsigned))
+{
+	u8 bank;
+	unsigned bank_base;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	for (bank = 0; bank < pctl->desc->irq_banks; bank++) {
+		bank_base = pctl->desc->irq_bank_base[bank];
+		writel(mask[bank], pctl->membase + (*func)(bank, bank_base));
+	}
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
+}
+
+static int sunxi_pinctrl_suspend(struct device *device)
+{
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(device);
+	const struct sunxi_pinctrl_desc *desc = pctl->desc;
+	unsigned long flags;
+	u8 bank, i;
+	u32 *regs = pctl->regs_backup, *bank_membase;
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	for (bank = 0; bank < desc->banks; bank++) {
+		bank_membase = pctl->membase + (desc->bank_base[bank] + bank)
+								* BANK_MEM_SIZE;
+		for (i = 0; i < BANK_MEM_SIZE/4; i++)
+			*regs++ = readl(bank_membase + i);
+	}
+
+	for (bank = 0; bank < desc->irq_banks; bank++) {
+		bank_membase = pctl->membase + IRQ_CFG_REG +
+				(desc->irq_bank_base[bank] + bank) * IRQ_MEM_SIZE;
+		for (i = 0; i < IRQ_CFG_SIZE/4; i++)
+			*regs++ = readl(bank_membase + i);
+		*regs++ = readl(pctl->membase +
+				sunxi_irq_debounce_reg_from_bank(bank, pctl->desc->irq_bank_base[bank]));
+	}
+#ifdef CONFIG_SUNXI_PIO_POWER_MODE
+	*regs++ = readl(pctl->membase + GPIO_POW_MODE_SEL);
+#endif
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	/* store the pins irq mask */
+	sunxi_pinctrl_get_intc_mask(pctl, pctl->cur_mask,
+				    sunxi_irq_ctrl_reg_from_bank);
+	/* enable the wakeup pins irq */
+	sunxi_pinctrl_set_intc_mask(pctl, pctl->wake_mask,
+				    sunxi_irq_ctrl_reg_from_bank);
+
+	/* store the pins irq debounce */
+	sunxi_pinctrl_get_intc_mask(pctl, pctl->cur_debounce,
+				    sunxi_irq_debounce_reg_from_bank);
+	/* set the pins irq debounce */
+	sunxi_pinctrl_set_intc_mask(pctl, pctl->wake_debounce,
+				    sunxi_irq_debounce_reg_from_bank);
+
+	return 0;
+}
+
+static int sunxi_pinctrl_resume(struct device *device)
+{
+	struct sunxi_pinctrl *pctl = dev_get_drvdata(device);
+	const struct sunxi_pinctrl_desc *desc = pctl->desc;
+	unsigned long flags;
+	int bank, i;
+	u32 *regs = pctl->regs_backup, *bank_membase;
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	for (bank = 0; bank < desc->banks; bank++) {
+		bank_membase = pctl->membase + (desc->bank_base[bank] + bank)
+								* BANK_MEM_SIZE;
+		for (i = 0; i < BANK_MEM_SIZE/4; i++)
+			writel(*regs++, bank_membase + i);
+	}
+
+	for (bank = 0; bank < desc->irq_banks; bank++) {
+		bank_membase = pctl->membase + IRQ_CFG_REG +
+				(desc->irq_bank_base[bank] + bank) * IRQ_MEM_SIZE;
+		for (i = 0; i < IRQ_CFG_SIZE/4; i++)
+			writel(*regs++, bank_membase + i);
+		writel(*regs++, pctl->membase +
+				sunxi_irq_debounce_reg_from_bank(bank,
+					pctl->desc->irq_bank_base[bank]));
+	}
+#ifdef CONFIG_SUNXI_PIO_POWER_MODE
+	writel(*regs++, pctl->membase + GPIO_POW_MODE_SEL);
+#endif
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	/* restore the pins irq mask */
+	sunxi_pinctrl_set_intc_mask(pctl, pctl->cur_mask,
+				    sunxi_irq_ctrl_reg_from_bank);
+
+	/* restore the pins irq debounce */
+	sunxi_pinctrl_set_intc_mask(pctl, pctl->cur_debounce,
+				    sunxi_irq_debounce_reg_from_bank);
+
+	return 0;
+}
+
+const struct dev_pm_ops sunxi_pinctrl_pm_ops = {
+	.suspend_noirq = sunxi_pinctrl_suspend,
+	.resume_noirq = sunxi_pinctrl_resume,
+};
+
 static struct irq_chip sunxi_pinctrl_edge_irq_chip = {
 	.name		= "sunxi_pio_edge",
 	.irq_ack	= sunxi_pinctrl_irq_ack,
@@ -681,7 +1380,7 @@ static struct irq_chip sunxi_pinctrl_edg
 	.irq_request_resources = sunxi_pinctrl_irq_request_resources,
 	.irq_release_resources = sunxi_pinctrl_irq_release_resources,
 	.irq_set_type	= sunxi_pinctrl_irq_set_type,
-	.flags		= IRQCHIP_SKIP_SET_WAKE,
+	.irq_set_wake	= sunxi_pinctrl_irq_set_wake,
 };
 
 static struct irq_chip sunxi_pinctrl_level_irq_chip = {
@@ -696,8 +1395,8 @@ static struct irq_chip sunxi_pinctrl_lev
 	.irq_request_resources = sunxi_pinctrl_irq_request_resources,
 	.irq_release_resources = sunxi_pinctrl_irq_release_resources,
 	.irq_set_type	= sunxi_pinctrl_irq_set_type,
-	.flags		= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_EOI_THREADED |
-			  IRQCHIP_EOI_IF_HANDLED,
+	.irq_set_wake	= sunxi_pinctrl_irq_set_wake,
+	.flags		= IRQCHIP_EOI_THREADED | IRQCHIP_EOI_IF_HANDLED,
 };
 
 static int sunxi_pinctrl_irq_of_xlate(struct irq_domain *d,
@@ -727,7 +1426,7 @@ static int sunxi_pinctrl_irq_of_xlate(st
 	return 0;
 }
 
-static struct irq_domain_ops sunxi_pinctrl_irq_domain_ops = {
+static const struct irq_domain_ops sunxi_pinctrl_irq_domain_ops = {
 	.xlate		= sunxi_pinctrl_irq_of_xlate,
 };
 
@@ -737,7 +1436,9 @@ static void sunxi_pinctrl_irq_handler(st
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	struct sunxi_pinctrl *pctl = irq_desc_get_handler_data(desc);
 	unsigned long bank, reg, val;
+	unsigned int base_bank;
 
+	chained_irq_enter(chip, desc);
 	for (bank = 0; bank < pctl->desc->irq_banks; bank++)
 		if (irq == pctl->irq[bank])
 			break;
@@ -745,20 +1446,21 @@ static void sunxi_pinctrl_irq_handler(st
 	if (bank == pctl->desc->irq_banks)
 		return;
 
-	reg = sunxi_irq_status_reg_from_bank(bank, pctl->desc->irq_bank_base);
+	base_bank = pctl->desc->irq_bank_base[bank];
+	reg = sunxi_irq_status_reg_from_bank(bank, base_bank);
 	val = readl(pctl->membase + reg);
 
 	if (val) {
 		int irqoffset;
 
-		chained_irq_enter(chip, desc);
 		for_each_set_bit(irqoffset, &val, IRQ_PER_BANK) {
 			int pin_irq = irq_find_mapping(pctl->domain,
 						       bank * IRQ_PER_BANK + irqoffset);
 			generic_handle_irq(pin_irq);
 		}
-		chained_irq_exit(chip, desc);
 	}
+	chained_irq_exit(chip, desc);
+
 }
 
 static int sunxi_pinctrl_add_function(struct sunxi_pinctrl *pctl,
@@ -777,12 +1479,38 @@ static int sunxi_pinctrl_add_function(st
 
 	func->name = name;
 	func->ngroups = 1;
+	return 0;
+}
 
-	pctl->nfunctions++;
+static int sunxi_pinctrl_count_function(struct sunxi_pinctrl *pctl,
+					struct sunxi_pinctrl_function *func)
+{
+	int i = 0;
+	int nfunctions = 0;
+	/* Count functions */
+	for (i = 0; i < pctl->desc->npins; i++) {
+		const struct sunxi_desc_pin *pin = pctl->desc->pins + i;
+		struct sunxi_desc_function *func_desc = pin->functions;
 
-	return 0;
+		while (func_desc->name) {
+			struct sunxi_pinctrl_function *tmp_func = func;
+
+			while (tmp_func->name) {
+				if (strcmp(func_desc->name, tmp_func->name) == 0)
+					break;
+				tmp_func++;
+			}
+			if (!tmp_func->name) {
+				tmp_func->name = func_desc->name;
+				nfunctions++;
+			}
+			func_desc++;
+		}
+	}
+	return nfunctions;
 }
 
+
 static int sunxi_pinctrl_build_state(struct platform_device *pdev)
 {
 	struct sunxi_pinctrl *pctl = platform_get_drvdata(pdev);
@@ -806,16 +1534,16 @@ static int sunxi_pinctrl_build_state(str
 	}
 
 	/*
-	 * We suppose that we won't have any more functions than pins,
-	 * we'll reallocate that later anyway
+	 * We have known all functions of pin,so we should use
+	 * pctl->nfunctions instead of pctl->desc->npins to alloc buffer
 	 */
 	pctl->functions = devm_kzalloc(&pdev->dev,
-				pctl->desc->npins * sizeof(*pctl->functions),
+				pctl->nfunctions * sizeof(*pctl->functions),
 				GFP_KERNEL);
 	if (!pctl->functions)
 		return -ENOMEM;
 
-	/* Count functions and their associated groups */
+	/* Count functions associated groups */
 	for (i = 0; i < pctl->desc->npins; i++) {
 		const struct sunxi_desc_pin *pin = pctl->desc->pins + i;
 		struct sunxi_desc_function *func = pin->functions;
@@ -832,10 +1560,6 @@ static int sunxi_pinctrl_build_state(str
 		}
 	}
 
-	pctl->functions = krealloc(pctl->functions,
-				pctl->nfunctions * sizeof(*pctl->functions),
-				GFP_KERNEL);
-
 	for (i = 0; i < pctl->desc->npins; i++) {
 		const struct sunxi_desc_pin *pin = pctl->desc->pins + i;
 		struct sunxi_desc_function *func = pin->functions;
@@ -870,6 +1594,823 @@ static int sunxi_pinctrl_build_state(str
 	return 0;
 }
 
+static int sunxi_pinctrl_get_debounce_div(unsigned long clock_rate, int freq)
+{
+	unsigned int best_diff, best_div;
+	int i;
+
+	best_diff = abs(freq - clock_rate);
+	best_div = 0;
+
+	for (i = 1; i < 8; i++) {
+		int cur_diff = abs(freq - (clock_rate >> i));
+
+		if (cur_diff < best_diff) {
+			best_diff = cur_diff;
+			best_div = i;
+		}
+	}
+
+	return best_div;
+}
+
+static int sunxi_pinctrl_setup_debounce(struct sunxi_pinctrl *pctl,
+					struct device_node *node)
+{
+	unsigned long hosc_rate, losc_rate;
+	struct clk *hosc, *losc;
+	u8 div, src;
+	int i, ret;
+
+	/* Deal with old DTs that didn't have the oscillators */
+	if (of_count_phandle_with_args(node, "clocks", "#clock-cells") != 3)
+		return 0;
+	/* If we don't have any setup, bail out */
+	if (!of_find_property(node, "input-debounce", NULL))
+		return 0;
+
+	losc = devm_clk_get(pctl->dev, "losc");
+	if (IS_ERR(losc))
+		return PTR_ERR(losc);
+
+	hosc = devm_clk_get(pctl->dev, "hosc");
+	if (IS_ERR(hosc))
+		return PTR_ERR(hosc);
+
+	losc_rate = clk_get_rate(losc);
+	hosc_rate = clk_get_rate(hosc);
+
+	for (i = 0; i < pctl->desc->irq_banks; i++) {
+		unsigned long debounce_freq;
+		u32 debounce;
+
+		ret = of_property_read_u32_index(node, "input-debounce",
+						 i, &debounce);
+		if (ret)
+			return ret;
+
+		if (!debounce)
+			continue;
+
+		/*
+		 * if debounce > 1, freq = (1000000 + (debounce/2)) / debounce
+		 * else freq = (1000000 - (debounce/2)) / debounce
+		 */
+		debounce_freq = DIV_ROUND_CLOSEST(USEC_PER_SEC, debounce);
+
+		if (debounce_freq > hosc_rate) {
+			printk("not support set rate %ld, use max rate%ld\n",
+					debounce_freq, hosc_rate);
+			src = 1;
+			div = 0;
+		} else if (debounce_freq > losc_rate) {
+			printk("use hosc , set rate %ld\n", debounce_freq);
+			src = 1;
+			div = sunxi_pinctrl_get_debounce_div(hosc_rate,
+								  debounce_freq);
+		} else {
+			printk("use default, set min rate %ld\n", losc_rate);
+			src = 0;
+			div = 0;
+		}
+
+		writel(src | div << 4,
+		       pctl->membase +
+		       sunxi_irq_debounce_reg_from_bank(i,
+						pctl->desc->irq_bank_base[i]));
+	}
+
+	return 0;
+}
+
+/* Show sunxi pinctrl state, provide debug information */
+void sunxi_pinctrl_state_show(void)
+{
+	struct pinctrl_dev *pctldev;
+	struct sunxi_pinctrl *pctl;
+	unsigned long config;
+	unsigned i, pin, muxsel;
+
+	pctldev = get_pinctrl_dev_from_devname(SUNXI_PINCTRL);
+	if (!pctldev) {
+		pr_err("can't get pinctrl dev for %s\n", SUNXI_PINCTRL);
+		return;
+	}
+
+	pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	pr_info("pio function state: (%d pins registered)\n",
+		pctl->desc->npins);
+	pr_info("pin num (name): function    owner\n");
+
+	/* The pin number can be retrived from the pin controller descriptor */
+	for (i = 0; i < pctl->desc->npins; i++) {
+		struct pin_desc *desc;
+		struct sunxi_desc_function *func;
+
+		pin = pctldev->desc->pins[i].number;
+		desc = pin_desc_get(pctldev, pin);
+
+		/* Get real pin function */
+		config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, 0xFFFFFF);
+		sunxi_pconf_get(pctldev, pin, &config);
+		muxsel = SUNXI_PINCFG_UNPACK_VALUE(config);
+
+		func = pctl->desc->pins[i].functions;
+		while (func->name) {
+			if (func->muxval == muxsel)
+				break;
+			func++;
+		}
+
+		pr_info("pin %-3d (%-4s): %-11s %s\n", pin, desc->name,
+			 func->name ? func->name : "(UNCLAIMED)",
+			 desc->mux_owner ? desc->mux_owner : "(UNCLAIMED)");
+	}
+}
+EXPORT_SYMBOL_GPL(sunxi_pinctrl_state_show);
+
+int sunxi_sel_pio_mode(struct pinctrl *pinctrl, u32 pm_sel)
+{
+#ifdef CONFIG_SUNXI_PIO_POWER_MODE
+	struct pinctrl_setting const *setting;
+	struct sunxi_pinctrl *pctl;
+	struct pinctrl_dev *pctldev;
+	const struct pinctrl_ops *pctlops;
+	int ret, i;
+	const unsigned *pins = NULL;
+	unsigned num_pins = 0;
+	const char *gname;
+	u32 bank, tmp;
+#ifdef CONFIG_SUNXI_PIO_POWER_SEL
+	u32 tmp1;
+#endif
+	unsigned long flags;
+
+	list_for_each_entry(setting, &pinctrl->state->settings, node) {
+		if (setting->type != PIN_MAP_TYPE_MUX_GROUP)
+			continue;
+
+		pctldev = setting->pctldev;
+		pctlops = pctldev->desc->pctlops;
+
+		if (pctlops->get_group_pins)
+			ret = pctlops->get_group_pins(pctldev,
+						setting->data.mux.group,
+						&pins, &num_pins);
+
+		if (ret) {
+			gname = pctlops->get_group_name(pctldev,
+						setting->data.mux.group);
+			dev_err(pctldev->dev,
+				 "could not get pins for group %s\n", gname);
+			return -EINVAL;
+		}
+
+		pctl = pinctrl_dev_get_drvdata(pctldev);
+		for (i = 0; i < num_pins; i++) {
+			bank = pins[i] / PINS_PER_BANK;
+			raw_spin_lock_irqsave(&pctl->lock, flags);
+			tmp = readl(pctl->membase + GPIO_POW_MODE_SEL);
+			tmp |= (pm_sel << bank);
+			writel(tmp, pctl->membase + GPIO_POW_MODE_SEL);
+#ifdef CONFIG_SUNXI_PIO_POWER_SEL
+			if (bank == 5) {
+				tmp1 = readl(pctl->membase + GPIO_POW_VOL_SEL);
+				tmp1 &= ~(1>>0);
+				tmp1 |= (!pm_sel);
+				writel(tmp1, pctl->membase + GPIO_POW_VOL_SEL);
+			}
+#endif
+			raw_spin_unlock_irqrestore(&pctl->lock, flags);
+		}
+	}
+	return 0;
+#else
+	return -EINVAL;
+#endif
+}
+EXPORT_SYMBOL_GPL(sunxi_sel_pio_mode);
+
+#ifdef CONFIG_DEBUG_FS
+#define SUNXI_MAX_NAME_LEN 20
+static char sunxi_dbg_pinname[SUNXI_MAX_NAME_LEN];
+static char sunxi_dbg_devname[SUNXI_MAX_NAME_LEN] = SUNXI_PINCTRL;
+static unsigned long sunxi_dbg_function;
+static unsigned long sunxi_dbg_data;
+static unsigned long sunxi_dbg_level;
+static unsigned long sunxi_dbg_pull;
+
+static int sunxi_pin_configure_show(struct seq_file *s, void *d)
+{
+	int pin;
+	unsigned long config;
+	struct pinctrl_dev *pctldev;
+	struct sunxi_pinctrl *pctl;
+
+	/* get pinctrl device */
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev) {
+		seq_puts(s, "cannot get pinctrl device from devname\n");
+		return -EINVAL;
+	}
+
+	/* change pin name to pin index */
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+	pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	/*get pin func*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] funciton: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+
+	/*get pin data*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] data: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+
+	/*get pin dlevel*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DRV, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] dlevel: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+
+	/*get pin pull*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] pull: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+
+	return 0;
+}
+
+static ssize_t sunxi_pin_configure_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err;
+	int pin;
+	unsigned int function;
+	unsigned int data;
+	unsigned int pull;
+	unsigned int dlevel;
+	unsigned long config;
+	struct pinctrl_dev *pctldev;
+	struct sunxi_pinctrl *pctl;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	err = sscanf(buf, "%19s %u %u %u %u", sunxi_dbg_pinname,
+			&function, &data, &dlevel, &pull);
+	if (err != 6)
+		return -EINVAL;
+
+	if (function > 7) {
+		pr_err("Input Parameters function error!\n");
+		return -EINVAL;
+	}
+	sunxi_dbg_function = function;
+
+	if (data > 1) {
+		pr_err("Input Parameters data error!\n");
+		return -EINVAL;
+	}
+	sunxi_dbg_data = data;
+
+	if (pull > 3) {
+		pr_err("Input Parameters pull error!\n");
+		return -EINVAL;
+	}
+	sunxi_dbg_pull = pull;
+
+	if (dlevel > 3) {
+		pr_err("Input Parameters dlevel error!\n");
+		return -EINVAL;
+	}
+	sunxi_dbg_level = dlevel;
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+
+	pctl = pinctrl_dev_get_drvdata(pctldev);
+
+	/* set function value*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, function);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+	pr_debug("pin[%s] set function:     %x;\n",
+			sunxi_dbg_pinname, function);
+
+	/* set data value*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, data);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+	pr_debug("pin[%s] set data:     %x;\n", sunxi_dbg_pinname, data);
+
+	/* set dlevel value*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DRV, dlevel);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+	pr_debug("pin[%s] set dlevel:     %x;\n", sunxi_dbg_pinname, dlevel);
+
+	/* set pull value*/
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, pull);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+	pr_debug("pin[%s] set pull:     %x;\n", sunxi_dbg_pinname, pull);
+
+	return count;
+}
+
+static int sunxi_pin_show(struct seq_file *s, void *d)
+{
+	if (strlen(sunxi_dbg_pinname))
+		seq_printf(s, "%s\n", sunxi_dbg_pinname);
+	else
+		seq_puts(s, "No pin name set\n");
+
+	return 0;
+}
+
+static ssize_t sunxi_pin_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+
+	if (count > SUNXI_MAX_NAME_LEN)
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	err = sscanf(buf, "%19s", sunxi_dbg_pinname);
+	if (err != 1)
+		return -EINVAL;
+
+	return count;
+}
+
+static int sunxi_dev_name_show(struct seq_file *s, void *d)
+{
+	if (strlen(sunxi_dbg_devname))
+		seq_printf(s, "%s\n", sunxi_dbg_devname);
+	else
+		seq_puts(s, "No dev name set\n");
+
+	return 0;
+}
+
+static ssize_t sunxi_dev_name_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+
+	if (count > SUNXI_MAX_NAME_LEN)
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	err = sscanf(buf, "%19s", sunxi_dbg_devname);
+	if (err != 1)
+		return -EINVAL;
+
+	return count;
+}
+
+
+static int sunxi_pin_function_show(struct seq_file *s, void *d)
+{
+	unsigned long config;
+	struct pinctrl_dev *pctldev;
+	int pin;
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] funciton: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+	return 0;
+}
+
+static ssize_t sunxi_pin_function_write(struct file *file,
+		const char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	int err;
+	unsigned long function;
+	unsigned long config;
+	int pin;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+	struct pinctrl_dev *pctldev;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	err = sscanf(buf, "%19s %lu", sunxi_dbg_pinname, &function);
+	if (err != 2)
+		return err;
+
+	if (function > 7) {
+		pr_debug("Input Parameters function error!\n");
+		return -EINVAL;
+	}
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+
+	sunxi_dbg_function = function;
+
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, function);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+
+	return count;
+}
+
+static int sunxi_pin_data_show(struct seq_file *s, void *d)
+{
+	unsigned long config;
+	int pin;
+	struct pinctrl_dev *pctldev;
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] data: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+	return 0;
+}
+
+static ssize_t sunxi_pin_data_write(struct file *file,
+		const char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	int err;
+	unsigned long data;
+	unsigned long config;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+	int pin;
+	struct pinctrl_dev *pctldev;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	err = sscanf(buf, "%19s %lu", sunxi_dbg_pinname, &data);
+	if (err != 2)
+		return err;
+
+	if (data > 1) {
+		pr_debug("Input Parameters data error!\n");
+		return -EINVAL;
+	}
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+	sunxi_dbg_data = data;
+
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DAT, data);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+
+	return count;
+}
+
+static int sunxi_pin_dlevel_show(struct seq_file *s, void *d)
+{
+	unsigned long config;
+	int pin;
+	struct pinctrl_dev *pctldev;
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DRV, 0XFFFFFF);
+	pin_config_get(SUNXI_PINCTRL, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] dlevel: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+	return 0;
+}
+
+static ssize_t sunxi_pin_dlevel_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int err;
+	unsigned long dlevel;
+	unsigned long config;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+	int pin;
+	struct pinctrl_dev *pctldev;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	err = sscanf(buf, "%19s %lu", sunxi_dbg_pinname, &dlevel);
+	if (err != 2)
+		return err;
+
+	if (dlevel > 3) {
+		pr_debug("Input Parameters dlevel error!\n");
+		return -EINVAL;
+	}
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+
+	sunxi_dbg_level = dlevel;
+
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_DRV, dlevel);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+
+	return count;
+}
+
+static int sunxi_pin_pull_show(struct seq_file *s, void *d)
+{
+	unsigned long config;
+	int pin;
+	struct pinctrl_dev *pctldev;
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, 0XFFFFFF);
+	pin_config_get(sunxi_dbg_devname, sunxi_dbg_pinname, &config);
+	seq_printf(s, "pin[%s] pull: %lx\n", sunxi_dbg_pinname,
+			SUNXI_PINCFG_UNPACK_VALUE(config));
+	return 0;
+}
+
+static ssize_t sunxi_pin_pull_write(struct file *file,
+		const char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	int err;
+	unsigned long pull;
+	unsigned long config;
+	unsigned char buf[SUNXI_MAX_NAME_LEN];
+	int pin;
+	struct pinctrl_dev *pctldev;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	err = sscanf(buf, "%19s %lu", sunxi_dbg_pinname, &pull);
+	if (err != 2)
+		return err;
+
+	if (pull > 3) {
+		pr_debug("Input Parameters pull error!\n");
+		return -EINVAL;
+	}
+
+	pctldev = get_pinctrl_dev_from_devname(sunxi_dbg_devname);
+	if (!pctldev)
+		return -EINVAL;
+
+	pin = pin_get_from_name(pctldev, sunxi_dbg_pinname);
+	if (pin < 0) {
+		pr_err("unvalid pin:%s for sunxi_dbg_devname:%s\n", sunxi_dbg_pinname, sunxi_dbg_devname);
+		return -EINVAL;
+	}
+
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, pull);
+	pin_config_set(sunxi_dbg_devname, sunxi_dbg_pinname, config);
+
+	return count;
+}
+
+static int sunxi_platform_show(struct seq_file *s, void *d)
+{
+#if defined(CONFIG_ARCH_SUN8IW10P1)
+	seq_puts(s, "SUN8IW10P1\n");
+#elif defined(CONFIG_ARCH_SUN8IW11P1)
+	seq_puts(s, "SUN8IW11P1\n");
+#elif defined(CONFIG_ARCH_SUN8IW7P1)
+	seq_puts(s, "SUN8IW7P1\n");
+#elif defined(CONFIG_ARCH_SUN50IW1P1)
+	seq_puts(s, "SUN50IW1P1\n");
+#elif defined(CONFIG_ARCH_SUN50IW2P1)
+	seq_puts(s, "SUN50IW2P1\n");
+#elif defined(CONFIG_ARCH_SUN50IW3P1)
+	seq_puts(s, "SUN50IW3P1\n");
+#elif defined(CONFIG_ARCH_SUN50IW6P1)
+	seq_puts(s, "SUN50IW6P1\n");
+#elif defined(CONFIG_ARCH_SUN3IW1P1)
+	seq_puts(s, "SUN3IW1P1\n");
+#else
+	seq_puts(s, "NOMATCH\n");
+#endif
+	return 0;
+}
+
+static ssize_t sunxi_platform_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	return count;
+}
+
+static int sunxi_pin_configure_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_pin_configure_show, inode->i_private);
+}
+
+static int sunxi_pin_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_pin_show, inode->i_private);
+}
+
+static int sunxi_dev_name_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_dev_name_show, inode->i_private);
+}
+
+static int sunxi_pin_function_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_pin_function_show, inode->i_private);
+}
+
+static int sunxi_pin_data_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_pin_data_show, inode->i_private);
+}
+
+static int sunxi_pin_dlevel_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_pin_dlevel_show, inode->i_private);
+}
+
+static int sunxi_pin_pull_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_pin_pull_show, inode->i_private);
+}
+
+static int sunxi_platform_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sunxi_platform_show, inode->i_private);
+}
+
+static const struct file_operations sunxi_pin_configure_ops = {
+	.open		= sunxi_pin_configure_open,
+	.write		= sunxi_pin_configure_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_pin_ops = {
+	.open		= sunxi_pin_open,
+	.write		= sunxi_pin_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_dev_name_ops = {
+	.open		= sunxi_dev_name_open,
+	.write		= sunxi_dev_name_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_pin_function_ops = {
+	.open		= sunxi_pin_function_open,
+	.write		= sunxi_pin_function_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_pin_data_ops = {
+	.open		= sunxi_pin_data_open,
+	.write		= sunxi_pin_data_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_pin_dlevel_ops = {
+	.open		= sunxi_pin_dlevel_open,
+	.write		= sunxi_pin_dlevel_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_pin_pull_ops = {
+	.open		= sunxi_pin_pull_open,
+	.write		= sunxi_pin_pull_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static const struct file_operations sunxi_platform_ops = {
+	.open		= sunxi_platform_open,
+	.write		= sunxi_platform_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static struct dentry *debugfs_root;
+
+static void sunxi_pinctrl_debugfs(void)
+{
+	debugfs_root = debugfs_create_dir("sunxi_pinctrl", NULL);
+	if (IS_ERR(debugfs_root) || !debugfs_root) {
+		pr_debug("failed to create debugfs directory\n");
+		debugfs_root = NULL;
+		return;
+	}
+
+	debugfs_create_file("sunxi_pin_configure",
+				(S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_pin_configure_ops);
+	debugfs_create_file("sunxi_pin", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_pin_ops);
+	debugfs_create_file("function", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_pin_function_ops);
+	debugfs_create_file("data", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_pin_data_ops);
+	debugfs_create_file("dlevel", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_pin_dlevel_ops);
+	debugfs_create_file("pull", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_pin_pull_ops);
+	debugfs_create_file("platform", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_platform_ops);
+	debugfs_create_file("dev_name", (S_IRUGO | S_IWUSR | S_IWGRP),
+			    debugfs_root, NULL, &sunxi_dev_name_ops);
+
+}
+#endif
 int sunxi_pinctrl_init(struct platform_device *pdev,
 		       const struct sunxi_pinctrl_desc *desc)
 {
@@ -877,16 +2418,18 @@ int sunxi_pinctrl_init(struct platform_d
 	struct pinctrl_desc *pctrl_desc;
 	struct pinctrl_pin_desc *pins;
 	struct sunxi_pinctrl *pctl;
+	struct pinmux_ops *pmxops;
 	struct resource *res;
 	int i, ret, last_pin;
 	struct clk *clk;
+	struct sunxi_pinctrl_function *func;
 
 	pctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);
 	if (!pctl)
 		return -ENOMEM;
 	platform_set_drvdata(pdev, pctl);
 
-	spin_lock_init(&pctl->lock);
+	raw_spin_lock_init(&pctl->lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	pctl->membase = devm_ioremap_resource(&pdev->dev, res);
@@ -902,6 +2445,45 @@ int sunxi_pinctrl_init(struct platform_d
 				       GFP_KERNEL);
 	if (!pctl->irq_array)
 		return -ENOMEM;
+	pctl->wake_mask = devm_kcalloc(&pdev->dev,
+					pctl->desc->irq_banks,
+					sizeof(*pctl->wake_mask),
+					GFP_KERNEL);
+	if (!pctl->wake_mask)
+		return -ENOMEM;
+	pctl->cur_mask = devm_kcalloc(&pdev->dev,
+					pctl->desc->irq_banks,
+					sizeof(*pctl->cur_mask),
+					GFP_KERNEL);
+	if (!pctl->cur_mask)
+		return -ENOMEM;
+
+	pctl->wake_debounce = devm_kcalloc(&pdev->dev,
+					pctl->desc->irq_banks,
+					sizeof(*pctl->wake_debounce),
+					GFP_KERNEL);
+	if (!pctl->wake_debounce)
+		return -ENOMEM;
+
+	pctl->cur_debounce = devm_kcalloc(&pdev->dev,
+					pctl->desc->irq_banks,
+					sizeof(*pctl->cur_debounce),
+					GFP_KERNEL);
+	if (!pctl->cur_debounce)
+		return -ENOMEM;
+
+	/*
+	 * alloc a temp buffer for count the pin
+	 * functions,and then we shuold free it
+	 */
+	func = kzalloc(pctl->desc->npins * sizeof(*pctl->functions) * 7,
+		       GFP_KERNEL);
+	if (!func)
+		return -ENOMEM;
+	/* count the pin functions for using in sunxi_pinctrl_build_state */
+	pctl->nfunctions = sunxi_pinctrl_count_function(pctl, func);
+
+	kfree(func);
 
 	ret = sunxi_pinctrl_build_state(pdev);
 	if (ret) {
@@ -930,17 +2512,35 @@ int sunxi_pinctrl_init(struct platform_d
 	pctrl_desc->npins = pctl->desc->npins;
 	pctrl_desc->confops = &sunxi_pconf_ops;
 	pctrl_desc->pctlops = &sunxi_pctrl_ops;
-	pctrl_desc->pmxops =  &sunxi_pmx_ops;
 
-	pctl->pctl_dev = devm_pinctrl_register(&pdev->dev, pctrl_desc, pctl);
+	pmxops = devm_kmemdup(&pdev->dev, &sunxi_pmx_ops, sizeof(sunxi_pmx_ops),
+			      GFP_KERNEL);
+	if (!pmxops)
+		return -ENOMEM;
+
+	if (desc->disable_strict_mode)
+		pmxops->strict = false;
+
+	pctrl_desc->pmxops = pmxops;
+
+	pctl->pctl_dev = pinctrl_register(pctrl_desc,
+					  &pdev->dev, pctl);
 	if (IS_ERR(pctl->pctl_dev)) {
 		dev_err(&pdev->dev, "couldn't register pinctrl driver\n");
 		return PTR_ERR(pctl->pctl_dev);
 	}
 
+	pctl->regs_backup = devm_kzalloc(&pdev->dev,
+		pctl->desc->banks * BANK_MEM_SIZE +  /* bank regs */
+		pctl->desc->irq_banks * IRQ_MEM_SIZE + /* irq regs */
+		4, /* power mode reg */
+		GFP_KERNEL);
+
 	pctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);
-	if (!pctl->chip)
-		return -ENOMEM;
+	if (!pctl->chip) {
+		ret = -ENOMEM;
+		goto pinctrl_error;
+	}
 
 	last_pin = pctl->desc->pins[pctl->desc->npins - 1].pin.number;
 	pctl->chip->owner = THIS_MODULE;
@@ -950,19 +2550,20 @@ int sunxi_pinctrl_init(struct platform_d
 	pctl->chip->direction_output = sunxi_pinctrl_gpio_direction_output,
 	pctl->chip->get = sunxi_pinctrl_gpio_get,
 	pctl->chip->set = sunxi_pinctrl_gpio_set,
+	pctl->chip->set_debounce = sunxi_pinctrl_gpio_set_debounce,
 	pctl->chip->of_xlate = sunxi_pinctrl_gpio_of_xlate,
 	pctl->chip->to_irq = sunxi_pinctrl_gpio_to_irq,
-	pctl->chip->of_gpio_n_cells = 3,
+	pctl->chip->of_gpio_n_cells = 6,
 	pctl->chip->can_sleep = false,
-	pctl->chip->ngpio = round_up(last_pin, PINS_PER_BANK) -
+	pctl->chip->ngpio = round_up(last_pin + 1, PINS_PER_BANK) -
 			    pctl->desc->pin_base;
 	pctl->chip->label = dev_name(&pdev->dev);
 	pctl->chip->parent = &pdev->dev;
 	pctl->chip->base = pctl->desc->pin_base;
 
-	ret = gpiochip_add_data(pctl->chip, pctl);
+	ret = gpiochip_add(pctl->chip);
 	if (ret)
-		return ret;
+		goto pinctrl_error;
 
 	for (i = 0; i < pctl->desc->npins; i++) {
 		const struct sunxi_desc_pin *pin = pctl->desc->pins + i;
@@ -1021,17 +2622,24 @@ int sunxi_pinctrl_init(struct platform_d
 
 	for (i = 0; i < pctl->desc->irq_banks; i++) {
 		/* Mask and clear all IRQs before registering a handler */
-		writel(0, pctl->membase + sunxi_irq_ctrl_reg_from_bank(i,
-						pctl->desc->irq_bank_base));
-		writel(0xffffffff,
-		       pctl->membase + sunxi_irq_status_reg_from_bank(i,
-						pctl->desc->irq_bank_base));
+		unsigned bank_base = pctl->desc->irq_bank_base[i];
+
+		writel(0, pctl->membase +
+			sunxi_irq_ctrl_reg_from_bank(i, bank_base));
+		writel(0xffffffff, pctl->membase +
+			sunxi_irq_status_reg_from_bank(i, bank_base));
 
 		irq_set_chained_handler_and_data(pctl->irq[i],
 						 sunxi_pinctrl_irq_handler,
 						 pctl);
 	}
 
+#ifdef CONFIG_DEBUG_FS
+	sunxi_pinctrl_debugfs();
+#endif
+
+	sunxi_pinctrl_setup_debounce(pctl, node);
+
 	dev_info(&pdev->dev, "initialized sunXi PIO driver\n");
 
 	return 0;
@@ -1040,5 +2648,7 @@ clk_error:
 	clk_disable_unprepare(clk);
 gpiochip_error:
 	gpiochip_remove(pctl->chip);
+pinctrl_error:
+	pinctrl_unregister(pctl->pctl_dev);
 	return ret;
 }
