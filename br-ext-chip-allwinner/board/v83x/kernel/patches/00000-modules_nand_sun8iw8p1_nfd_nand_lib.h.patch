diff -drupN a/modules/nand/sun8iw8p1/nfd/nand_lib.h b/modules/nand/sun8iw8p1/nfd/nand_lib.h
--- a/modules/nand/sun8iw8p1/nfd/nand_lib.h	1970-01-01 03:00:00.000000000 +0300
+++ b/modules/nand/sun8iw8p1/nfd/nand_lib.h	2022-06-12 05:28:14.000000000 +0300
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2007-2019 Allwinnertech Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __BSP_NAND_H__
+#define __BSP_NAND_H__
+
+#include "nand_type.h"
+
+/*for partition*/
+#define MAX_PART_COUNT_PER_FTL		24
+#define MAX_PARTITION        		4
+#define ND_MAX_PARTITION_COUNT      (MAX_PART_COUNT_PER_FTL*MAX_PARTITION)
+
+typedef struct {
+	__u8        ChipCnt;                            /*the count of the total nand flash chips are currently connecting on the CE pin*/
+	__u16       ChipConnectInfo;                    /*chip connect information, bit == 1 means there is a chip connecting on the CE pin*/
+	__u8        ConnectMode;						/*the rb connect  mode*/
+	__u8        BankCntPerChip;                     /*the count of the banks in one nand chip, multiple banks can support Inter-Leave*/
+	__u8        DieCntPerChip;                      /*the count of the dies in one nand chip, block management is based on Die*/
+	__u8        PlaneCntPerDie;                     /*the count of planes in one die, multiple planes can support multi-plane operation*/
+	__u8        SectorCntPerPage;                   /*the count of sectors in one single physic page, one sector is 0.5k*/
+	__u16       PageCntPerPhyBlk;                   /*the count of physic pages in one physic block*/
+	__u32       BlkCntPerDie;                       /*the count of the physic blocks in one die, include valid block and invalid block*/
+	__u32       OperationOpt;                       /*the mask of the operation types which current nand flash can support support*/
+	__u16       FrequencePar;                       /*the parameter of the hardware access clock, based on 'MHz'*/
+	__u32       SpiMode;                            /*spi nand mode, 0:mode 0, 3:mode 3*/
+	__u8        NandChipId[8];                      /*the nand chip id of current connecting nand chip*/
+	__u32		pagewithbadflag;					/*bad block flag was written at the first byte of spare area of this page*/
+	__u32       MultiPlaneBlockOffset;              /*the value of the block number offset between the two plane block*/
+	__u32       MaxEraseTimes;              		/*the max erase times of a physic block*/
+	__u32		MaxEccBits;							/*the max ecc bits that nand support*/
+	__u32		EccLimitBits;						/*the ecc limit flag for tne nand*/
+	__u32		Reserved[4];
+} boot_nand_para_t;
+
+typedef struct boot_flash_info {
+	__u32 chip_cnt;
+	__u32 blk_cnt_per_chip;
+	__u32 blocksize;
+	__u32 pagesize;
+	__u32 pagewithbadflag; /*bad block flag was written at the first byte of spare area of this page*/
+} boot_flash_info_t;
+
+struct boot_physical_param {
+	__u32   chip; /*chip no*/
+	__u32  block; /* block no within chip*/
+	__u32  page; /* apge no within block*/
+	__u32  sectorbitmap;
+	void   *mainbuf; /*data buf*/
+	void   *oobbuf; /*oob buf*/
+};
+
+typedef struct _Boot_file_head {
+	__u32  jump_instruction;   /* one intruction jumping to real code*/
+	__u8   magic[8];           /* ="eGON.BT0" or "eGON.BT1",  not C-style string.*/
+	__u32  check_sum;          /* generated by PC*/
+	__u32  length;             /* generated by PC*/
+	__u32  pub_head_size;      /* the size of boot_file_head_t*/
+	__u8   pub_head_vsn[4];    /* the version of boot_file_head_t*/
+	__u8   file_head_vsn[4];   /* the version of boot0_file_head_t or boot1_file_head_t*/
+	__u8   Boot_vsn[4];        /* Boot version*/
+	__u8   eGON_vsn[4];        /* eGON version*/
+	__u8   platform[8];        /* platform information*/
+} boot_file_head_t;
+
+
+#define PARTITION_NAME_SIZE  16
+
+struct _nand_disk {
+	unsigned int		size;
+	/*unsigned int offset;*/
+	unsigned int		type;
+	unsigned  char      name[PARTITION_NAME_SIZE];
+};
+
+struct _nand_phy_partition {
+	void *dat;
+};
+
+/*extern struct _nand_phy_partition;*/
+
+struct _nftl_blk {
+	unsigned int                            nftl_logic_size;
+	struct _nand_partition                 *nand;
+	struct _nftl_blk                       *nftl_blk_next;
+	void                                   *nftl_zone;
+	void                                   *cfg;
+	unsigned int		                    time;
+	unsigned int		        			ops_time;	/* add ecape time for ops nftl */
+	unsigned int		                    time_flush;
+	void                                   *nftl_thread;
+	void                                   *blk_lock;
+	int (*read_data)(struct _nftl_blk *nftl_blk, unsigned int sector, unsigned int len, unsigned char *buf);
+	int (*write_data)(struct _nftl_blk *nftl_blk, unsigned int sector, unsigned int len, unsigned char *buf);
+	int (*flush_write_cache)(struct _nftl_blk *nftl_blk, unsigned int num);
+	int (*discard)(struct _nftl_blk *nftl_blk, unsigned int sector, unsigned int len);
+	int (*shutdown_op)(struct _nftl_blk *nftl_blk);
+	int (*read_sector_data)(struct _nftl_blk *nftl_blk, unsigned int sector, unsigned int len, unsigned char *buf);
+	int (*write_sector_data)(struct _nftl_blk *nftl_blk, unsigned int sector, unsigned int len, unsigned char *buf);
+	int (*flush_sector_write_cache)(struct _nftl_blk *nftl_blk, unsigned int num);
+};
+
+extern __s32 PHY_SimpleErase(struct boot_physical_param *eraseop);
+extern __s32 PHY_SimpleRead(struct boot_physical_param *readop);
+extern __s32 PHY_SimpleWrite(struct boot_physical_param *writeop);
+
+extern void ClearNandStruct(void);
+
+/*for param get&set*/
+extern __u32 NAND_GetFrequencePar(void);
+extern __s32 NAND_SetFrequencePar(__u32 FrequencePar);
+extern __u32 NAND_GetNandVersion(void);
+extern __s32 NAND_GetParam(boot_nand_para_t *nand_param);
+extern __s32 NAND_GetFlashInfo(boot_flash_info_t *info);
+extern __u32 NAND_GetChipCnt(void);
+extern __u32 NAND_GetBlkCntPerChip(void);
+
+struct _nand_info *NandHwInit(void);
+__s32 NandHwExit(void);
+__s32 NandHwSuperStandby(void);
+__s32 NandHwSuperResume(void);
+__s32 NandHwNormalStandby(void);
+__s32 NandHwNormalResume(void);
+__s32 NandHwShutDown(void);
+
+int test_mbr(uchar *data);
+
+/*for NFTL*/
+int nftl_initialize(struct _nftl_blk *nftl_blk, int no);
+extern int nand_info_init(struct _nand_info *nand_info, unsigned char chip, uint16 start_block, unsigned char *mbr_data);
+
+
+#endif  /*ifndef __BSP_NAND_H__*/
