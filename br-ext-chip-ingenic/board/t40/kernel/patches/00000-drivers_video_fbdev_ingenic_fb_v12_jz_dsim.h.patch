diff -drupN a/drivers/video/fbdev/ingenic/fb_v12/jz_dsim.h b/drivers/video/fbdev/ingenic/fb_v12/jz_dsim.h
--- a/drivers/video/fbdev/ingenic/fb_v12/jz_dsim.h	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/video/fbdev/ingenic/fb_v12/jz_dsim.h	2022-06-09 05:02:34.000000000 +0300
@@ -0,0 +1,293 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef _JZ_MIPI_DSIM_H
+#define _JZ_MIPI_DSIM_H
+
+#include <linux/device.h>
+#include <linux/fb.h>
+
+#define REFERENCE_FREQ (24000)  //24MHZ, ext
+#define DPHY_DIV_UPPER_LIMIT    (40000)
+#define DPHY_DIV_LOWER_LIMIT    (1000)
+#define MIN_OUTPUT_FREQ		(80)
+
+#define DSIH_FIFO_ACTIVE_WAIT	500
+
+#define PRECISION_FACTOR	(1000)
+#define DSIH_PIXEL_TOLERANCE	2
+
+#define VIDEO_PACKET_OVERHEAD   6
+#define NULL_PACKET_OVERHEAD    6
+#define SHORT_PACKET		4
+#define BLANKING_PACKET         6
+#define MAX_NULL_SIZE		1023
+#define TX_ESC_CLK_DIV		7
+#define MAX_WORD_COUNT     150
+#define PANEL_NAME_SIZE     (32)
+
+
+enum dsi_interface_type {
+	DSIM_COMMAND,
+	DSIM_VIDEO
+};
+
+enum dsi_virtual_ch_no {
+	DSIM_VIRTUAL_CH_0,
+	DSIM_VIRTUAL_CH_1,
+	DSIM_VIRTUAL_CH_2,
+	DSIM_VIRTUAL_CH_3
+};
+
+enum dsi_no_of_data_lane {
+	DSIM_DATA_LANE_1,
+	DSIM_DATA_LANE_2,
+	DSIM_DATA_LANE_3,
+	DSIM_DATA_LANE_4
+};
+
+enum dsi_byte_clk_src {
+	DSIM_PLL_OUT_DIV8,
+	DSIM_EXT_CLK_DIV8,
+	DSIM_EXT_CLK_BYPASS
+};
+
+struct dsi_config {
+	unsigned char max_lanes;
+	unsigned char max_hs_to_lp_cycles;
+	unsigned char max_lp_to_hs_cycles;
+	unsigned short max_bta_cycles;
+	unsigned int max_bps;
+	int color_mode_polarity;
+	int shut_down_polarity;
+	int te_gpio;
+	int te_irq_level;
+	int te_mipi_en;
+
+};
+
+typedef enum {
+	OK = 0,
+	ERR_DSI_COLOR_CODING,
+	ERR_DSI_OUT_OF_BOUND,
+	ERR_DSI_OVERFLOW,
+	ERR_DSI_INVALID_INSTANCE,
+	ERR_DSI_CORE_INCOMPATIBLE,
+	ERR_DSI_VIDEO_MODE,
+	ERR_DSI_INVALID_COMMAND,
+	ERR_DSI_INVALID_EVENT,
+	ERR_DSI_INVALID_HANDLE,
+	ERR_DSI_PHY_POWERUP,
+	ERR_DSI_PHY_INVALID,
+	ERR_DSI_PHY_FREQ_OUT_OF_BOUND,
+	ERR_DSI_TIMEOUT
+} dsih_error_t;
+
+enum {
+	DSI_BLANK_UNBLANK,
+	DSI_BLANK_NORMAL,
+	DSI_BLANK_POWERDOWN,
+	DSI_BLANK_POWERUP
+};
+typedef enum {
+	NOT_INITIALIZED = 0,
+	INITIALIZED,
+	ON,
+	OFF,
+	UBOOT_INITIALIZED
+} dsih_state_t;
+
+typedef enum {
+	VIDEO_NON_BURST_WITH_SYNC_PULSES = 0,
+	VIDEO_NON_BURST_WITH_SYNC_EVENTS,
+	VIDEO_BURST_WITH_SYNC_PULSES
+} dsih_video_mode_t;
+/**
+ *  * Color coding type (depth and pixel configuration)
+ *   */
+typedef enum {
+	COLOR_CODE_16BIT_CONFIG1,
+	COLOR_CODE_16BIT_CONFIG2,
+	COLOR_CODE_16BIT_CONFIG3,
+	COLOR_CODE_18BIT_CONFIG1,
+	COLOR_CODE_18BIT_CONFIG2,
+	COLOR_CODE_24BIT
+} dsih_color_coding_t;
+
+typedef enum {
+	MIPI_PHY_BYTE_CLK_COEF_MUL1 = 0,
+	MIPI_PHY_BYTE_CLK_COEF_MUL3_DIV2 = 1,
+	MIPI_PHY_BYTE_CLK_COEF_MUL4_DIV3 = 2,
+	MIPI_PHY_BYTE_CLK_COEF_MUL5_DIV4 = 3,
+	MIPI_PHY_BYTE_CLK_COEF_MUL6_DIV5 = 4,
+} byte_clock_coef_t;
+
+struct video_config {
+	unsigned char no_of_lanes;
+	unsigned char virtual_channel;
+	dsih_video_mode_t video_mode;
+	int receive_ack_packets;
+	unsigned int byte_clock;
+	byte_clock_coef_t byte_clock_coef;
+	unsigned int pixel_clock;
+	dsih_color_coding_t color_coding;
+	int is_18_loosely;
+	int data_en_polarity;
+	int h_polarity;
+	unsigned short h_active_pixels;	/* hadr */
+	unsigned short h_sync_pixels;
+	unsigned short h_back_porch_pixels;	/* hbp */
+	unsigned short h_total_pixels;	/* h_total */
+	int v_polarity;
+	unsigned short v_active_lines;	/* vadr */
+	unsigned short v_sync_lines;
+	unsigned short v_back_porch_lines;	/* vbp */
+	unsigned short v_total_lines;	/* v_total */
+	unsigned int refresh;
+};
+
+
+struct dsi_device {
+	unsigned int __iomem address;
+	unsigned int __iomem phy_address;
+	struct mutex lock;
+	spinlock_t	irq_lock;
+	struct clk *clk;
+	struct dsi_config *dsi_config;
+	struct dsi_phy *dsi_phy;
+	struct video_config *video_config;
+	struct dsi_master_ops *master_ops;
+	struct mipi_dsim_lcd_device *dsim_lcd_dev;
+	struct mipi_dsim_lcd_driver *dsim_lcd_drv;
+
+
+	struct dsi_cmd_packet *cmd_list;
+	int cmd_packet_len;
+	unsigned int state;
+	unsigned int data_lane;
+	bool suspended;
+	int counter;
+
+};
+
+struct dsi_phy {
+	unsigned int reference_freq;
+	dsih_state_t status;
+	unsigned int address;
+	void (*bsp_pre_config) (struct dsi_device * dsi, void *param);
+
+};
+
+struct mipi_dsim_lcd_device {
+	char            *name;
+	struct device       dev;
+	int         id;
+	int         bus_id;
+	int         irq;
+	int         panel_reverse;
+
+	struct dsi_device *master;
+	void            *platform_data;
+};
+
+enum {
+    POWER_ON_LCD = 1,
+    POWER_ON_BL,
+};
+enum {
+    CMD_MIPI_DISPLAY_ON = 1,
+    CMD_MIPI_END,
+};
+struct mipi_dsim_lcd_driver {
+	char            *name;
+	int         id;
+
+	void    (*power_on)(struct mipi_dsim_lcd_device *dsim_dev, int mode);
+	void    (*set_sequence)(struct mipi_dsim_lcd_device *dsim_dev);
+	int    (*ioctl)(struct mipi_dsim_lcd_device *dsim_dev, int cmd);
+	int (*probe)(struct mipi_dsim_lcd_device *dsim_dev);
+	int (*remove)(struct mipi_dsim_lcd_device *dsim_dev);
+	void    (*shutdown)(struct mipi_dsim_lcd_device *dsim_dev);
+	int (*suspend)(struct mipi_dsim_lcd_device *dsim_dev);
+	int (*resume)(struct mipi_dsim_lcd_device *dsim_dev);
+};
+struct mipi_dsim_platform_data {
+	char				lcd_panel_name[PANEL_NAME_SIZE];
+
+	struct mipi_dsim_config		*dsim_config;
+	unsigned int			enabled;
+	void				*lcd_panel_info;
+};
+
+struct dsi_cmd_packet {
+	unsigned char packet_type;
+	unsigned char cmd0_or_wc_lsb;
+	unsigned char cmd1_or_wc_msb;
+	unsigned char cmd_data[MAX_WORD_COUNT];
+};
+
+typedef struct {
+	/** Register offset */
+	unsigned int addr;
+	/** Register data [in or out]*/
+	unsigned int data;
+} register_config_t;
+
+struct freq_ranges {
+	unsigned int freq;	/* upper margin of frequency range */
+	unsigned char hs_freq;	/* hsfreqrange */
+	unsigned char vco_range;	/* vcorange */
+};
+
+struct loop_band {
+	unsigned int loop_div;	/* upper limit of loop divider range */
+	unsigned char cp_current;	/* icpctrl */
+	unsigned char lpf_resistor;	/* lpfctrl */
+};
+
+/*
+ * struct dsi_master_ops - callbacks to mipi-dsi operations.
+ *
+ * @cmd_write: transfer command to lcd panel at LP mode.
+ * @cmd_read: read command from rx register.
+ * @get_dsi_frame_done: get the status that all screen data have been
+ *	transferred to mipi-dsi.
+ * @clear_dsi_frame_done: clear frame done status.
+ * @get_fb_frame_done: get frame done status of display controller.
+ * @trigger: trigger display controller.
+ *	- this one would be used only in case of CPU mode.
+ *  @set_early_blank_mode: set framebuffer blank mode.
+ *	- this callback should be called prior to fb_blank() by a client driver
+ *	only if needing.
+ *  @set_blank_mode: set framebuffer blank mode.
+ *	- this callback should be called after fb_blank() by a client driver
+ *	only if needing.
+ */
+
+struct dsi_master_ops {
+	int (*cmd_write) (struct dsi_device * dsi, struct dsi_cmd_packet cmd_data);
+	int (*cmd_read) (struct dsi_device * dsi, u8 * rx_buf);
+	int (*video_cfg) (struct dsi_device * dsi);
+	int (*mode_cfg) (struct dsi_device *dsi, int mode);
+	int (*query_te) (struct dsi_device *dsi);
+	int (*set_early_blank_mode)(struct dsi_device *dsi, int power);
+	int (*set_blank_mode)(struct dsi_device *dsi, int power);
+	int (*set_blank)(struct dsi_device *dsi, int blank_mode);
+    int (*ioctl)(struct dsi_device *dsi, int cmd);
+};
+
+extern struct jzdsi_data jzdsi_pdata;
+int mipi_dsi_register_lcd_device(struct mipi_dsim_lcd_device
+		                        *lcd_dev);
+/**
+ *  * register mipi_dsim_lcd_driver object defined by lcd panel driver
+ *   * to mipi-dsi driver.
+ *    */
+int mipi_dsi_register_lcd_driver(struct mipi_dsim_lcd_driver
+		                        *lcd_drv);
+
+
+#endif /* _JZ_MIPI_DSIM_H */
