diff -drupN a/drivers/video/fbdev/ingenic/fb_v10/ingenicfb.c b/drivers/video/fbdev/ingenic/fb_v10/ingenicfb.c
--- a/drivers/video/fbdev/ingenic/fb_v10/ingenicfb.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/video/fbdev/ingenic/fb_v10/ingenicfb.c	2022-06-09 05:02:34.000000000 +0300
@@ -0,0 +1,2667 @@
+/*
+ * kernel/drivers/video/ingenic_fb_v1_2/ingenic_fb.c
+ *
+ * Copyright (c) 2012 Ingenic Semiconductor Co., Ltd.
+ *              http://www.ingenic.com/
+ *
+ * Core file for Ingenic Display Controller driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/mm.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/memory.h>
+#include <linux/suspend.h>
+#include <linux/string.h>
+#include <linux/kthread.h>
+#include <linux/gpio.h>
+#include <linux/clk-provider.h>
+#include <asm/cacheflush.h>
+//#include <mach/platform.h>
+//#include <soc/gpio.h>
+//#include <mach/ingenicfb.h>
+
+#include "ingenicfb.h"
+#include "lcd_regs.h"
+struct ingenicfb_platform_data *fbdev_panel = NULL;
+struct platform_device *fbdev_pdev = NULL;
+static void dump_lcdc_registers(struct ingenicfb *ingenicfb);
+static void ingenicfb_enable(struct fb_info *info);
+static void ingenicfb_disable(struct fb_info *info);
+static int ingenicfb_set_par(struct fb_info *info);
+
+static int uboot_inited;
+static int showFPS = 0;
+static struct ingenicfb *ingenicfb;
+
+static const struct fb_fix_screeninfo ingenicfb_fix  = {
+	.id = "ingenicfb",
+	.type = FB_TYPE_PACKED_PIXELS,
+	.visual = FB_VISUAL_TRUECOLOR,
+	.xpanstep = 0,
+	.ypanstep = 1,
+	.ywrapstep = 0,
+	.accel = FB_ACCEL_NONE,
+};
+
+void ingenicfb_clk_enable(struct ingenicfb *ingenicfb);
+void ingenicfb_clk_disable(struct ingenicfb *ingenicfb);
+void ingenicfb_pclk_enable(struct ingenicfb *ingenicfb);
+void ingenicfb_pclk_disable(struct ingenicfb *ingenicfb);
+static int ingenicfb_open(struct fb_info *info, int user)
+{
+	struct ingenicfb *ingenicfb = info->par;
+
+	dev_dbg(info->dev, "open count : %d\n", ++ingenicfb->open_cnt);
+
+	if (!ingenicfb->is_lcd_en && ingenicfb->vidmem_phys) {
+#ifdef CONFIG_SLCDC_LOW_POWER_CONSUMPTION
+		ingenicfb_clk_enable(ingenicfb);
+		ingenicfb_pclk_enable(ingenicfb);
+#endif
+		if (ingenicfb->is_inited == 0)
+			ingenicfb_set_par(info);
+
+		ingenicfb_enable(info);
+	}
+
+	return 0;
+}
+
+static int ingenicfb_release(struct fb_info *info, int user)
+{
+	unsigned int tmp = 0;
+
+	tmp = reg_read(ingenicfb, SLCDC_CTRL);
+#ifdef CONFIG_SLCDC_CONTINUA
+	tmp &= ~(SLCDC_CTRL_DMA_START | SLCDC_CTRL_DMA_MODE);
+#else
+	tmp |= SLCDC_CTRL_DMA_MODE | SLCDC_CTRL_DMA_START;
+#endif
+	reg_write(ingenicfb, SLCDC_CTRL, tmp);
+
+#ifdef CONFIG_SLCDC_LOW_POWER_CONSUMPTION
+	msleep(100);
+	ingenicfb_disable(ingenicfb->fb);
+	ingenicfb_pclk_disable(ingenicfb);
+	ingenicfb_clk_disable(ingenicfb);
+#endif
+	return 0;
+}
+
+	static void
+ingenicfb_videomode_to_var(struct fb_var_screeninfo *var,
+		const struct fb_videomode *mode, int lcd_type)
+{
+	var->xres = mode->xres;
+	var->yres = mode->yres;
+	var->xres_virtual = mode->xres;
+	var->yres_virtual = mode->yres * NUM_FRAME_BUFFERS;
+	var->xoffset = 0;
+	var->yoffset = 0;
+	var->left_margin = mode->left_margin;
+	var->right_margin = mode->right_margin;
+	var->upper_margin = mode->upper_margin;
+	var->lower_margin = mode->lower_margin;
+	var->hsync_len = mode->hsync_len;
+	var->vsync_len = mode->vsync_len;
+	var->sync = mode->sync;
+	var->vmode = mode->vmode & FB_VMODE_MASK;
+	if (lcd_type == LCD_TYPE_SLCD) {
+		uint64_t pixclk =
+			KHZ2PICOS((var->xres + var->left_margin +
+						var->hsync_len) * (var->yres +
+							var->upper_margin +
+							var->lower_margin +
+							var->vsync_len) * 60 / 1000);
+		var->pixclock =
+			(mode->pixclock < pixclk) ? pixclk : mode->pixclock;
+	} else {
+		var->pixclock = mode->pixclock;
+	}
+}
+
+static int ingenicfb_get_controller_bpp(struct ingenicfb *ingenicfb)
+{
+	switch (ingenicfb->fb_bpp) {
+		case 18:
+		case 24:
+			return 32;
+		case 15:
+			return 16;
+		default:
+			return ingenicfb->fb_bpp;
+	}
+}
+
+static struct fb_videomode *ingenicfb_get_mode(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	size_t i;
+	struct ingenicfb *ingenicfb = info->par;
+	struct fb_videomode *mode = ingenicfb->pdata->modes;
+
+	for (i = 0; i < ingenicfb->pdata->num_modes; ++i, ++mode) {
+		if (mode->flag & FB_MODE_IS_VGA) {
+			if (mode->xres == var->xres &&
+					mode->yres == var->yres
+					&& mode->pixclock == var->pixclock)
+				return mode;
+		} else {
+			if (mode->xres == var->xres && mode->yres == var->yres
+					&& mode->vmode == var->vmode
+					&& mode->right_margin == var->right_margin) {
+				if (ingenicfb->pdata->lcd_type != LCD_TYPE_SLCD) {
+					if (mode->pixclock == var->pixclock)
+						return mode;
+				} else {
+					return mode;
+				}
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static struct fb_videomode *ingenicfb_checkout_max_vga_videomode(struct fb_info
+		*info)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_platform_data *pdata = ingenicfb->pdata;
+	int i, flag;
+	int pix_size = 0;
+	flag = 0;
+	for (i = 0; i < pdata->num_modes; i++) {
+		if ((pdata->modes[i].xres * pdata->modes[i].yres) > pix_size) {
+			flag = pdata->modes[i].flag;
+			pix_size = pdata->modes[i].xres * pdata->modes[i].yres;
+		}
+	}
+
+	for (i = 0; i < pdata->num_modes; i++) {
+		if (pdata->modes[i].flag != flag)
+			continue;
+		return &pdata->modes[i];
+	}
+
+	if (i > pdata->num_modes) {
+		dev_err(ingenicfb->dev, "Find video mode fail\n");
+		return NULL;
+	}
+
+	return NULL;
+}
+
+static void ingenicfb_config_fg0(struct fb_info *info)
+{
+	unsigned int rgb_ctrl, cfg;
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_osd_t *osd = &ingenicfb->osd;
+	struct fb_videomode *mode = info->mode;
+
+	if (!mode) {
+		dev_err(ingenicfb->dev, "%s, video mode is NULL\n", __func__);
+		return;
+	}
+	osd->fg0.fg = 0;
+	osd->fg0.bpp = ingenicfb_get_controller_bpp(ingenicfb) == 32 ? 32 : 16;
+	osd->fg0.x = osd->fg0.y = 0;
+	osd->fg0.w = mode->xres;
+	osd->fg0.h = mode->yres;
+
+	/* OSD mode enable and alpha blending is enabled */
+	cfg = LCDC_OSDC_OSDEN | LCDC_OSDC_ALPHAEN;
+	cfg |= 1 << 16;		/* once transfer two pixels */
+
+	if (ingenicfb->fmt_order == FORMAT_X8B8G8R8) {
+		rgb_ctrl =
+			LCDC_RGBC_RGBFMT | LCDC_RGBC_ODD_BGR | LCDC_RGBC_EVEN_BGR;
+	} else {
+		/* default: FORMAT_X8R8G8B8 */
+		rgb_ctrl =
+			LCDC_RGBC_RGBFMT | LCDC_RGBC_ODD_RGB | LCDC_RGBC_EVEN_RGB;
+	}
+
+	//	reg_write(ingenicfb, LCDC_OSDC, cfg);
+	//	reg_write(ingenicfb, LCDC_OSDCTRL, ctrl);
+	reg_write(ingenicfb, LCDC_RGBC, rgb_ctrl);
+}
+
+	static int
+ingenicfb_calculate_size(struct fb_info *info, struct ingenicfb_display_size *size)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	struct fb_videomode *mode = info->mode;
+
+	if (!mode) {
+		dev_err(ingenicfb->dev, "%s, video mode is NULL\n", __func__);
+		return -EINVAL;
+	}
+	/*
+	 * The rules of f0, f1's position:
+	 * f0.x + f0.w <= panel.w;
+	 * f0.y + f0.h <= panel.h;
+	 */
+	if ((ingenicfb->osd.fg0.x + ingenicfb->osd.fg0.w > mode->xres) |
+			(ingenicfb->osd.fg0.y + ingenicfb->osd.fg0.h > mode->yres) |
+			(ingenicfb->osd.fg0.x >= mode->xres) | (ingenicfb->osd.fg0.y >= mode->yres)) {
+		dev_info(info->dev, "Invalid foreground size or position");
+		return -EINVAL;
+	}
+
+	/* lcd display area */
+	size->fg0_line_size = ingenicfb->osd.fg0.w * ingenicfb->osd.fg0.bpp >> 3;
+	/* word aligned and in word */
+	size->fg0_line_size = ALIGN(size->fg0_line_size, 4) >> 2;
+	size->fg0_frm_size = size->fg0_line_size * ingenicfb->osd.fg0.h;
+
+	/* panel PIXEL_ALIGN stride buffer area */
+	size->panel_line_size = ALIGN(mode->xres, PIXEL_ALIGN) *
+		(ingenicfb->osd.fg0.bpp >> 3);
+	/* word aligned and in word */
+	size->panel_line_size = ALIGN(size->panel_line_size, 4) >> 2;
+	ingenicfb->frm_size = size->panel_line_size * mode->yres << 2;
+
+	size->height_width = (ingenicfb->osd.fg0.h - 1) << LCDC_DESSIZE_HEIGHT_BIT
+		& LCDC_DESSIZE_HEIGHT_MASK;
+	size->height_width |= ((ingenicfb->osd.fg0.w - 1) << LCDC_DESSIZE_WIDTH_BIT
+			& LCDC_DESSIZE_WIDTH_MASK);
+
+	return 0;
+}
+
+	static void
+ingenicfb_config_tft_lcd_dma(struct fb_info *info,
+		struct ingenicfb_display_size *size,
+		struct ingenicfb_framedesc *framedesc)
+{
+	struct ingenicfb *ingenicfb = info->par;
+
+	framedesc->next = ingenicfb->framedesc_phys;
+	framedesc->databuf = ingenicfb->vidmem_phys;
+	framedesc->id = 0xda0;
+
+	framedesc->cmd = LCDC_CMD_EOFINT | LCDC_CMD_FRM_EN;
+	if (!ingenicfb->osd.block) {
+		framedesc->cmd |= size->fg0_frm_size;
+		framedesc->offsize =
+			(size->panel_line_size - size->fg0_line_size);
+	} else {
+		framedesc->cmd |= LCDC_CMD_16X16BLOCK;
+		framedesc->cmd |= (ingenicfb->osd.fg0.h & LCDC_CMD_LEN_MASK);
+		/* block size */
+		/* framedesc->offsize = size->fg0_frm_size; */
+	}
+
+	if (framedesc->offsize == 0) {
+		framedesc->page_width = 0;
+	} else {
+		framedesc->page_width = size->fg0_line_size;
+	}
+
+	if (ingenicfb->framedesc[0]->cpos & LCDC_CPOS_ALPHAMD1)
+		/* per pixel alpha mode */
+		framedesc->cpos = LCDC_CPOS_ALPHAMD1;
+	else
+		framedesc->cpos = 0;
+
+	switch (ingenicfb->osd.fg0.bpp) {
+		case 16:
+			framedesc->cpos |= LCDC_CPOS_RGB_RGB565 | LCDC_CPOS_BPP_16;
+			break;
+		case 30:
+			framedesc->cpos |= LCDC_CPOS_BPP_30;
+			break;
+		default:
+			framedesc->cpos |= LCDC_CPOS_BPP_18_24;
+			break;
+	}
+
+	/* data has not been premultied */
+	framedesc->cpos |= LCDC_CPOS_PREMULTI;
+	/* coef_sle 0 use 1 */
+	framedesc->cpos |= LCDC_CPOS_COEF_SLE_1;
+	framedesc->cpos |= (ingenicfb->osd.fg0.y << LCDC_CPOS_YPOS_BIT
+			& LCDC_CPOS_YPOS_MASK);
+	framedesc->cpos |= (ingenicfb->osd.fg0.x << LCDC_CPOS_XPOS_BIT
+			& LCDC_CPOS_XPOS_MASK);
+
+	/* fg0 alpha value */
+	framedesc->desc_size = 0xff << LCDC_DESSIZE_ALPHA_BIT;
+	framedesc->desc_size |= size->height_width;
+}
+
+	static void
+ingenicfb_config_smart_lcd_dma(struct fb_info *info,
+		struct ingenicfb_display_size *size,
+		struct ingenicfb_framedesc *framedesc)
+{
+	struct ingenicfb *ingenicfb = info->par;
+
+	framedesc->next =
+		ingenicfb->framedesc_phys +
+		sizeof(struct ingenicfb_framedesc) * (ingenicfb->desc_num - 2);
+	framedesc->databuf = ingenicfb->vidmem_phys;
+	framedesc->id = 0xda0da0;
+
+	framedesc->cmd = LCDC_CMD_EOFINT | LCDC_CMD_FRM_EN;
+	framedesc->cmd |= size->fg0_frm_size;
+
+	if (ingenicfb->framedesc[0]->cpos & LCDC_CPOS_ALPHAMD1)
+		/* per pixel alpha mode */
+		framedesc->cpos = LCDC_CPOS_ALPHAMD1;
+	else
+		framedesc->cpos = 0;
+	framedesc->offsize = (size->panel_line_size - size->fg0_line_size);
+	if (framedesc->offsize == 0) {
+		framedesc->page_width = 0;
+	} else {
+		framedesc->page_width = size->fg0_line_size;
+	}
+
+	switch (ingenicfb->osd.fg0.bpp) {
+		case 16:
+			framedesc->cpos |= LCDC_CPOS_RGB_RGB565 | LCDC_CPOS_BPP_16;
+			break;
+		case 30:
+			framedesc->cpos |= LCDC_CPOS_BPP_30;
+			break;
+		default:
+			framedesc->cpos |= LCDC_CPOS_BPP_18_24;
+			break;
+	}
+	/* data has not been premultied */
+	framedesc->cpos |= LCDC_CPOS_PREMULTI;
+	/* coef_sle 0 use 1 */
+	framedesc->cpos |= LCDC_CPOS_COEF_SLE_1;
+	framedesc->cpos |= (ingenicfb->osd.fg0.y << LCDC_CPOS_YPOS_BIT
+			& LCDC_CPOS_YPOS_MASK);
+	framedesc->cpos |= (ingenicfb->osd.fg0.x << LCDC_CPOS_XPOS_BIT
+			& LCDC_CPOS_XPOS_MASK);
+
+	/* fg0 alpha value */
+	framedesc->desc_size = 0xff << LCDC_DESSIZE_ALPHA_BIT;
+	framedesc->desc_size |= size->height_width;
+
+	framedesc[1].next = ingenicfb->framedesc_phys;
+	framedesc[1].databuf = 0;
+	framedesc[1].id = 0xda0da1;
+	framedesc[1].cmd = LCDC_CMD_CMD | LCDC_CMD_FRM_EN | 0;
+	framedesc[1].offsize = 0;
+	framedesc[1].page_width = 0;
+	framedesc[1].cpos = 0;
+	framedesc[1].desc_size = 0;
+
+	framedesc[2].next = ingenicfb->framedesc_phys;
+	framedesc[2].databuf = ingenicfb->desc_cmd_phys;
+	framedesc[2].id = 0xda0da2;
+	framedesc[2].offsize = 0;
+	framedesc[2].page_width = 0;
+	framedesc[2].desc_size = 0;
+
+	/*must to optimize*/
+	switch (ingenicfb->pdata->smart_config.bus_width) {
+		case 8:
+			framedesc[2].cmd = LCDC_CMD_CMD | LCDC_CMD_FRM_EN | 1;
+			framedesc[2].cpos = 4;
+			break;
+		case 9:
+		case 16:
+			framedesc[2].cmd = LCDC_CMD_CMD | LCDC_CMD_FRM_EN | 1;
+			framedesc[2].cpos = 2;
+			break;
+		default:
+			framedesc[2].cmd = LCDC_CMD_CMD | LCDC_CMD_FRM_EN | 1;
+			framedesc[2].cpos = 1;
+			break;
+	}
+}
+#if 0
+	static void
+ingenicfb_config_fg1_dma(struct fb_info *info, struct ingenicfb_display_size *size)
+{
+	struct ingenicfb *ingenicfb = info->par;
+
+	/*
+	 * the descriptor of DMA 1 just init once
+	 * and generally no need to use it
+	 */
+	if (ingenicfb->fg1_framedesc){
+		reg_write(ingenicfb, LCDC_DA1, ingenicfb->fg1_framedesc->next);
+		return;
+	}
+
+	ingenicfb->fg1_framedesc = ingenicfb->framedesc[0] + (ingenicfb->desc_num - 1);
+	ingenicfb->fg1_framedesc->next =
+		ingenicfb->framedesc_phys +
+		sizeof(struct ingenicfb_framedesc) * (ingenicfb->desc_num - 1);
+
+	ingenicfb->fg1_framedesc->databuf = 0;
+	ingenicfb->fg1_framedesc->id = 0xda1;
+	ingenicfb->fg1_framedesc->cmd = (LCDC_CMD_EOFINT & ~LCDC_CMD_FRM_EN)
+		| size->fg0_frm_size;
+	ingenicfb->fg1_framedesc->offsize = 0;
+	ingenicfb->fg1_framedesc->page_width = 0;
+
+	/* global alpha mode, data has not been premultied, COEF_SLE is 11 */
+	ingenicfb->fg1_framedesc->cpos = LCDC_CPOS_BPP_18_24 | ingenicfb->osd.fg0.y <<
+		LCDC_CPOS_YPOS_BIT | ingenicfb->osd.fg0.x | LCDC_CPOS_PREMULTI
+		| LCDC_CPOS_COEF_SLE_3;
+
+	ingenicfb->fg1_framedesc->desc_size = size->height_width | 0xff <<
+		LCDC_DESSIZE_ALPHA_BIT;
+
+	reg_write(ingenicfb, LCDC_DA1, ingenicfb->fg1_framedesc->next);
+}
+#endif
+static int ingenicfb_prepare_dma_desc(struct fb_info *info)
+{
+	int i;
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_display_size *display_size;
+	struct ingenicfb_framedesc *framedesc[MAX_DESC_NUM];
+	unsigned int val;
+	display_size = kmalloc(sizeof(struct ingenicfb_display_size), GFP_KERNEL);
+	framedesc[0] = kmalloc(sizeof(struct ingenicfb_framedesc) *
+			(ingenicfb->desc_num - 1), GFP_KERNEL);
+	for (i = 1; i < ingenicfb->desc_num - 1; i++)
+		framedesc[i] = framedesc[0] + i;
+
+	ingenicfb_calculate_size(info, display_size);
+
+	if (ingenicfb->pdata->lcd_type != LCD_TYPE_SLCD) {
+		ingenicfb_config_tft_lcd_dma(info, display_size, framedesc[0]);
+	} else {
+		ingenicfb_config_smart_lcd_dma(info, display_size, framedesc[0]);
+	}
+
+	for (i = 0; i < ingenicfb->desc_num - 1; i++) {
+		ingenicfb->framedesc[i]->next = framedesc[i]->next;
+		ingenicfb->framedesc[i]->databuf = framedesc[i]->databuf;
+		ingenicfb->framedesc[i]->id = framedesc[i]->id;
+		ingenicfb->framedesc[i]->cmd = framedesc[i]->cmd;
+		ingenicfb->framedesc[i]->offsize = framedesc[i]->offsize;
+		ingenicfb->framedesc[i]->page_width = framedesc[i]->page_width;
+		ingenicfb->framedesc[i]->cpos = framedesc[i]->cpos;
+		ingenicfb->framedesc[i]->desc_size = framedesc[i]->desc_size;
+	}
+
+	if (ingenicfb->pdata->lcd_type != LCD_TYPE_SLCD) {
+		reg_write(ingenicfb, LCDC_DA0, ingenicfb->framedesc[0]->next);
+	} else {
+		//reg_write(ingenicfb, LCDC_DA0, (unsigned int)virt_to_phys((void *)
+		//	reg_write(ingenicfb, LCDC_DA0, 0x20006666);
+		//reg_write(ingenicfb, LCDC_DA0, (unsigned int)virt_to_phys((void *)ingenicfb->framedesc[2]));
+		val = (unsigned int)ingenicfb->framedesc[2] - 0xa0000000;
+
+		reg_write(ingenicfb, LCDC_DA0, val);
+	}
+	//	ingenicfb_config_fg1_dma(info, display_size);
+	kzfree(framedesc[0]);
+	kzfree(display_size);
+
+	return 0;
+}
+
+static int ingenicfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	struct fb_videomode *mode;
+
+	if (var->bits_per_pixel != ingenicfb_get_controller_bpp(ingenicfb) &&
+			var->bits_per_pixel != ingenicfb->pdata->bpp)
+		return -EINVAL;
+	mode = ingenicfb_get_mode(var, info);
+	if (mode == NULL) {
+		dev_err(info->dev, "%s get video mode failed\n", __func__);
+		return -EINVAL;
+	}
+
+	ingenicfb_videomode_to_var(var, mode, ingenicfb->pdata->lcd_type);
+
+	switch (ingenicfb->fb_bpp) {
+		case 16:
+			var->red.offset = 11;
+			var->red.length = 5;
+			var->green.offset = 5;
+			var->green.length = 6;
+			var->blue.offset = 0;
+			var->blue.length = 5;
+			break;
+		case 17 ... 32:
+			if (ingenicfb->fmt_order == FORMAT_X8B8G8R8) {
+				var->red.offset = 0;
+				var->green.offset = 8;
+				var->blue.offset = 16;
+			} else {
+				/* default: FORMAT_X8R8G8B8 */
+				var->red.offset = 16;
+				var->green.offset = 8;
+				var->blue.offset = 0;
+			}
+
+			var->transp.offset = 24;
+			var->transp.length = 8;
+			var->red.length = 8;
+			var->green.length = 8;
+			var->blue.length = 8;
+			var->bits_per_pixel = 32;
+			break;
+		default:
+			dev_err(ingenicfb->dev, "Not support for %d bpp\n",
+					ingenicfb->pdata->bpp);
+			break;
+	}
+
+	return 0;
+}
+
+/* Sent a command without data (18-bit bus, 16-bit index) */
+static void slcd_send_mcu_command(struct ingenicfb *ingenicfb, unsigned long cmd)
+{
+	int count = 10000;
+	while ((reg_read(ingenicfb, SLCDC_STATE) & SLCDC_STATE_BUSY) && count--) {
+		udelay(10);
+	}
+	if (count < 0) {
+		dev_err(ingenicfb->dev, "SLCDC wait busy state wrong");
+	}
+	reg_write(ingenicfb, SLCDC_DATA, SLCDC_DATA_RS_COMMAND | cmd);
+}
+
+static void slcd_send_mcu_data(struct ingenicfb *ingenicfb, unsigned long data)
+{
+	int count = 10000;
+
+	while ((reg_read(ingenicfb, SLCDC_STATE) & SLCDC_STATE_BUSY) && count--) {
+		udelay(10);
+	}
+	if (count < 0) {
+		dev_err(ingenicfb->dev, "SLCDC wait busy state wrong");
+	}
+
+	reg_write(ingenicfb, SLCDC_DATA, SLCDC_DATA_RS_DATA | data);
+}
+
+static void ingenicfb_slcd_mcu_init(struct fb_info *info)
+{
+	unsigned int is_lcd_en, i, j;
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_platform_data *pdata = ingenicfb->pdata;
+	unsigned int data_table_width = pdata->smart_config.data_table_width;
+	unsigned int bus_width = pdata->smart_config.bus_width;
+
+	data_table_width = (data_table_width > bus_width) ? data_table_width : bus_width;
+
+	if (pdata->lcd_type != LCD_TYPE_SLCD)
+		return;
+
+	is_lcd_en = ingenicfb->is_lcd_en;
+	ingenicfb_enable(info);
+
+#ifndef CONFIG_GPIO_SIMULATE
+	if (pdata->smart_config.gpio_for_slcd) {
+		pdata->smart_config.gpio_for_slcd();
+	}
+#endif
+	/*
+	 *set cmd_width and data_width
+	 * */
+	if (pdata->smart_config.length_data_table
+			&& pdata->smart_config.data_table) {
+		for (i = 0; i < pdata->smart_config.length_data_table; i++) {
+			unsigned int value = pdata->smart_config.data_table[i].value;
+			switch (pdata->smart_config.data_table[i].type) {
+				case SMART_CONFIG_DATA:
+					for (j = data_table_width/bus_width; j>0; j--)
+						slcd_send_mcu_data(ingenicfb,
+								((value << (32 - bus_width * j)) >> (32 - bus_width)));
+					break;
+				case SMART_CONFIG_CMD:
+					for (j = data_table_width/bus_width; j>0; j--)
+						slcd_send_mcu_command(ingenicfb,
+								((value << (32 - bus_width * j)) >> (32 - bus_width)));
+					break;
+				case SMART_CONFIG_UDELAY:
+					udelay(value);
+					break;
+				default:
+					dev_err(ingenicfb->dev, "Unknow SLCD data type\n");
+					break;
+			}
+		}
+		{
+			int count = 10000;
+			while ((reg_read(ingenicfb, SLCDC_STATE) & SLCDC_STATE_BUSY)
+					&& count--) {
+				udelay(10);
+			}
+			if (count < 0) {
+				dev_err(ingenicfb->dev,
+						"SLCDC wait busy state wrong");
+			}
+
+		}
+
+	}
+
+	if(pdata->bpp / pdata->smart_config.bus_width != 1 ) {
+		int tmp = reg_read(ingenicfb, SLCDC_CFG_NEW);
+		tmp &= ~(SMART_LCD_NEW_DTIMES_MASK); //mask the 8~9bit
+		tmp |=  (pdata->bpp / pdata->smart_config.bus_width)  == 2 ? SMART_LCD_NEW_DTIMES_TWICE : SMART_LCD_NEW_DTIMES_THICE;
+		reg_write(ingenicfb, SLCDC_CFG_NEW, tmp);
+		dev_dbg(ingenicfb->dev, "the slcd  slcd_cfg_new is %08x\n", tmp);
+	}
+#ifdef CONFIG_LCD_TRULY_TFT240240_2_2E
+	reg_write(ingenicfb,SLCDC_CFG,reg_read(ingenicfb, SLCDC_CFG) & ~(0x01<<8));
+	reg_write(ingenicfb,SLCDC_CFG_NEW,reg_read(ingenicfb,SLCDC_CFG_NEW) | (0x01<<13));
+#endif
+#ifdef CONFIG_FB_INGENIC_DEBUG
+	/*for register mode test,
+	 * you can write test code according to the lcd panel
+	 **/
+#endif
+
+	/*recovery ori status*/
+	if (!is_lcd_en) {
+		ingenicfb_disable(info);
+	}
+
+}
+
+void ingenicfb_clk_enable(struct ingenicfb *ingenicfb)
+{
+	/* if(!__clk_is_enabled(ingenicfb->clk)) */
+	if(ingenicfb->is_clk_en)
+		return ;
+	clk_prepare_enable(ingenicfb->clk);
+	ingenicfb->is_clk_en = 1;
+}
+void ingenicfb_clk_disable(struct ingenicfb *ingenicfb)
+{
+	/* if(__clk_is_enabled(ingenicfb->clk)) */
+	if(!ingenicfb->is_clk_en)
+		return ;
+	ingenicfb->is_clk_en = 0;
+	clk_disable_unprepare(ingenicfb->clk);
+}
+
+void ingenicfb_pclk_enable(struct ingenicfb *ingenicfb)
+{
+//	if(!__clk_is_enabled(ingenicfb->pclk))
+	if(ingenicfb->is_pclk_en)
+		return ;
+	clk_prepare_enable(ingenicfb->pclk);
+	ingenicfb->is_pclk_en = 1;
+}
+
+void ingenicfb_pclk_disable(struct ingenicfb *ingenicfb)
+{
+//	if(__clk_is_enabled(ingenicfb->pclk))
+	if(!ingenicfb->is_pclk_en)
+		return ;
+	ingenicfb->is_pclk_en = 0;
+	clk_disable_unprepare(ingenicfb->pclk);
+}
+
+static void ingenicfb_enable(struct fb_info *info)
+{
+	uint32_t ctrl;
+	struct ingenicfb *ingenicfb = info->par;
+	int count = 2000;
+
+	if (ingenicfb->is_lcd_en) {
+		while ((reg_read(ingenicfb, SLCDC_STATE) & SLCDC_STATE_BUSY) && count) {
+			count--;
+			udelay(10);
+		}
+	}
+/*
+	if (!count)
+		dump_stack();
+*/
+	mutex_lock(&ingenicfb->lock);
+	if (ingenicfb->is_lcd_en) {
+		mutex_unlock(&ingenicfb->lock);
+		return;
+	}
+
+	reg_write(ingenicfb, LCDC_STATE, 0);
+	ctrl = reg_read(ingenicfb, LCDC_CTRL);
+	ctrl |= LCDC_CTRL_ENA;
+	reg_write(ingenicfb, LCDC_CTRL, ctrl);
+
+	ingenicfb->is_lcd_en = 1;
+	mutex_unlock(&ingenicfb->lock);
+}
+
+static void ingenicfb_disable(struct fb_info *info)
+{
+	uint32_t ctrl;
+	struct ingenicfb *ingenicfb = info->par;
+
+	mutex_lock(&ingenicfb->lock);
+	if (!ingenicfb->is_lcd_en) {
+		mutex_unlock(&ingenicfb->lock);
+		return;
+	}
+
+	/* SLCD and TVE only support quick disable */
+	ctrl = reg_read(ingenicfb, LCDC_CTRL);
+	ctrl &= ~LCDC_CTRL_ENA;
+	reg_write(ingenicfb, LCDC_CTRL, ctrl);
+	ingenicfb->is_lcd_en = 0;
+	udelay(10);
+	mutex_unlock(&ingenicfb->lock);
+
+}
+
+static int ingenicfb_set_par(struct fb_info *info)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_platform_data *pdata = ingenicfb->pdata;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_videomode *mode;
+	int is_lcd_en;
+	uint16_t hds, vds;
+	uint16_t hde, vde;
+	uint16_t ht, vt;
+	uint32_t cfg, ctrl;
+	uint32_t smart_cfg = 0, smart_ctrl = 0;
+	uint32_t smart_new_cfg = 0;
+	uint32_t smart_wtime = 0, smart_tas = 0;
+	uint32_t pcfg;
+	unsigned long rate;
+
+	mode = ingenicfb_get_mode(var, info);
+	if (mode == NULL) {
+		dev_err(info->dev, "%s get video mode failed\n", __func__);
+		return -EINVAL;
+	}
+#if 0
+	if (mode == info->mode){
+		printk("+++++mode=%d  info->mode=%d\n",mode,info->mode);
+		return 0;
+	}
+#endif
+	info->mode = mode;
+
+	hds = mode->hsync_len + mode->left_margin;
+	hde = hds + mode->xres;
+	ht = hde + mode->right_margin;
+
+	vds = mode->vsync_len + mode->upper_margin;
+	vde = vds + mode->yres;
+	vt = vde + mode->lower_margin;
+
+	/*
+	 * configure LCDC config register
+	 * use 8words descriptor, not use palette
+	 * ! M200 NOT SUPPORT PALETTE FUNCTION, DO NOT SET LCDC_CFG_PALBP(BIT27), IT CAUGHT BPP16 COLOR ERROR.
+	 */
+	/*SET PALBP TO AVOID FORMAT TRANSFER */
+
+	cfg = LCDC_CFG_NEWDES | LCDC_CFG_RECOVER;
+	cfg |= pdata->lcd_type;
+
+	if (!(mode->sync & FB_SYNC_HOR_HIGH_ACT))
+		cfg |= LCDC_CFG_HSP;
+
+	if (!(mode->sync & FB_SYNC_VERT_HIGH_ACT))
+		cfg |= LCDC_CFG_VSP;
+
+	if (pdata->pixclk_falling_edge)
+		cfg |= LCDC_CFG_PCP;
+
+	if (pdata->data_enable_active_low)
+		cfg |= LCDC_CFG_DEP;
+
+	/* configure LCDC control register */
+	ctrl = LCDC_CTRL_BST_64 | LCDC_CTRL_OFUM;
+	if (pdata->pinmd)
+		ctrl |= LCDC_CTRL_PINMD;
+
+	pcfg = 0xC0000000 | (511 << 18) | (400 << 9) | (256 << 0);
+
+	/* configure smart LCDC registers */
+	if (pdata->lcd_type == LCD_TYPE_SLCD) {
+		switch(pdata->smart_config.bus_width){
+			case 8:
+				smart_cfg |= SMART_LCD_CWIDTH_8_BIT_ONCE;
+				smart_new_cfg |= SMART_LCD_NEW_DWIDTH_8_BIT;
+				break;
+			case 9:
+#ifdef CONFIG_LCD_TRULY_TFT240240_2_2E
+				smart_cfg |= SMART_LCD_CWIDTH_8_BIT_ONCE;
+				smart_new_cfg |= SMART_LCD_NEW_DWIDTH_8_BIT;
+#else
+				smart_cfg |= SMART_LCD_CWIDTH_9_BIT_ONCE;
+				smart_new_cfg |= SMART_LCD_NEW_DWIDTH_16_BIT;
+#endif
+				break;
+			case 16:
+				smart_cfg |= SMART_LCD_CWIDTH_16_BIT_ONCE;
+				smart_new_cfg |= SMART_LCD_NEW_DWIDTH_16_BIT;
+				break;
+			case 18:
+				smart_cfg |= SMART_LCD_CWIDTH_18_BIT_ONCE;
+				smart_new_cfg |= SMART_LCD_NEW_DWIDTH_18_BIT;
+				break;
+			case 24:
+				smart_cfg |= SMART_LCD_CWIDTH_24_BIT_ONCE;
+				smart_new_cfg |= SMART_LCD_NEW_DWIDTH_24_BIT;
+				break;
+			default:
+				printk("ERR: please check out your bus width config\n");
+				break;
+		}
+
+		if (pdata->smart_config.clkply_active_rising)
+			smart_cfg |= SLCDC_CFG_CLK_ACTIVE_RISING;
+		if (pdata->smart_config.rsply_cmd_high)
+			smart_cfg |= SLCDC_CFG_RS_CMD_HIGH;
+		if (pdata->smart_config.csply_active_high)
+			smart_cfg |= SLCDC_CFG_CS_ACTIVE_HIGH;
+
+		smart_ctrl = SLCDC_CTRL_DMA_MODE;
+		//smart_ctrl |= SLCDC_CTRL_GATE_MASK; //for saving power
+		smart_ctrl &= ~SLCDC_CTRL_GATE_MASK;
+
+		smart_ctrl |= (SLCDC_CTRL_NEW_MODE | SLCDC_CTRL_NOT_USE_TE | SLCDC_CTRL_FAST_MODE); //new slcd mode
+		smart_ctrl &= ~SLCDC_CTRL_MIPI_MODE;
+		smart_new_cfg |= SMART_LCD_NEW_DTIMES_ONCE;
+
+		if (pdata->smart_config.newcfg_6800_md)
+			smart_new_cfg |= SLCDC_NEW_CFG_6800_MD;
+		if (pdata->smart_config.datatx_type_serial
+				&& pdata->smart_config.cmdtx_type_serial)
+			smart_new_cfg |=
+				SLCDC_NEW_CFG_DTYPE_SERIAL |
+				SLCDC_NEW_CFG_CTYPE_SERIAL;
+		if (pdata->smart_config.newcfg_cmd_9bit)
+			smart_new_cfg |= SLCDC_NEW_CFG_CMD_9BIT;
+
+		smart_wtime = 0;
+		smart_tas = 0;
+	}
+
+	if (mode->pixclock) {
+		rate = PICOS2KHZ(mode->pixclock) * 1000;
+		mode->refresh = rate / vt / ht;
+	} else {
+		if (pdata->lcd_type == LCD_TYPE_8BIT_SERIAL) {
+			rate = mode->refresh * (vt + 2 * mode->xres) * ht;
+		} else {
+			rate = mode->refresh * vt * ht;
+		}
+		mode->pixclock = KHZ2PICOS(rate / 1000);
+
+		var->pixclock = mode->pixclock;
+	}
+	//	printk("lcd pixel rate is :::::::::::::::::::::::::::::::::::::::%d\n",rate);
+	/*set reg,and enable lcd after set all reg*/
+	is_lcd_en = ingenicfb->is_lcd_en;
+	ingenicfb_disable(info);
+
+	mutex_lock(&ingenicfb->lock);
+
+	switch (pdata->lcd_type) {
+		case LCD_TYPE_SPECIAL_TFT_1:
+		case LCD_TYPE_SPECIAL_TFT_2:
+		case LCD_TYPE_SPECIAL_TFT_3:
+			reg_write(ingenicfb, LCDC_SPL, pdata->special_tft_config.spl);
+			reg_write(ingenicfb, LCDC_CLS, pdata->special_tft_config.cls);
+			reg_write(ingenicfb, LCDC_PS, pdata->special_tft_config.ps);
+			reg_write(ingenicfb, LCDC_REV, pdata->special_tft_config.ps);
+			break;
+		default:
+			cfg |= LCDC_CFG_PSM;
+			cfg |= LCDC_CFG_CLSM;
+			cfg |= LCDC_CFG_SPLM;
+			cfg |= LCDC_CFG_REVM;
+			break;
+	}
+
+	if (pdata->lcd_type != LCD_TYPE_SLCD) {
+		reg_write(ingenicfb, LCDC_VAT, (ht << 16) | vt);
+
+		/*
+		 * If you are using a VGA output,
+		 * then you need to last a pix of the value is set to 0,
+		 * you can add the background size widened, that is,
+		 * the increase in the value of the VDE, plus at least 1,
+		 * the maximum can not exceed the value of VT.
+		 * Example:
+		 * LCD monitor manufacturers: ViewSonic
+		 * Model: VA926.
+		 * Set the resolution: 1280 * 1024
+		 * To set the parameters in xxx_lcd.c need to pay attention to:
+		 * 1. The timing need to use the standard timing
+		 * 2. If you will be using a VGA display, .flag = FB_MODE_IS_VGA
+		 * 3. sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		 *        The sync trigger for the high level active
+		 * 4. pixclk_falling_edge = 1, PIX clock trigger high level
+		 * 5. data_enable_active_low = 1, DATA enable is high level
+		 */
+
+		if (mode->flag & FB_MODE_IS_VGA) {
+			if ((hde + 8) <= ht)
+				hde += 8;
+			else if ((hde + 1) <= ht)
+				hde += 1;
+			/*
+			   if(vds > 2 && (vde + 2) <= vt){
+			   vds -= 2;
+			   vde += 2;
+			   }
+			   */
+			info->fix.line_length = info->var.bits_per_pixel *
+				ALIGN(mode->xres, PIXEL_ALIGN) >> 3;
+		}
+
+		reg_write(ingenicfb, LCDC_DAH, (hds << 16) | hde);
+		reg_write(ingenicfb, LCDC_DAV, (vds << 16) | vde);
+
+		reg_write(ingenicfb, LCDC_HSYNC, mode->hsync_len);
+		reg_write(ingenicfb, LCDC_VSYNC, mode->vsync_len);
+	} else {
+		reg_write(ingenicfb, LCDC_VAT, (mode->xres << 16) | mode->yres);
+		reg_write(ingenicfb, LCDC_DAH, mode->xres);
+		reg_write(ingenicfb, LCDC_DAV, mode->yres);
+
+		reg_write(ingenicfb, LCDC_HSYNC, 0);
+		reg_write(ingenicfb, LCDC_VSYNC, 0);
+
+		reg_write(ingenicfb, SLCDC_CFG, smart_cfg);
+		reg_write(ingenicfb, SLCDC_CTRL, smart_ctrl);
+
+		reg_write(ingenicfb, SLCDC_CFG_NEW, smart_new_cfg);
+		reg_write(ingenicfb, SLCDC_WTIME, smart_wtime);
+		reg_write(ingenicfb, SLCDC_TAS, smart_tas);
+
+	}
+
+	reg_write(ingenicfb, LCDC_CFG, cfg);
+	ctrl |= reg_read(ingenicfb, LCDC_CTRL);
+	reg_write(ingenicfb, LCDC_CTRL, ctrl);
+	reg_write(ingenicfb, LCDC_PCFG, pcfg);
+
+	ingenicfb_config_fg0(info);
+	//	printk("this once called ingenicfb_prepare_dma_desc() in this function::%s00000000000000\n",__func__);
+	ingenicfb_prepare_dma_desc(info);
+	mutex_unlock(&ingenicfb->lock);
+
+	ingenicfb_pclk_disable(ingenicfb);
+	clk_set_rate(ingenicfb->pclk, rate);
+	ingenicfb_pclk_enable(ingenicfb);
+
+	if (!ingenicfb->is_suspend) {
+		/*avoid printk after every wake up */
+		dev_dbg(ingenicfb->dev, "LCDC: PixClock:%lu\n", rate);
+		dev_dbg(ingenicfb->dev, "LCDC: PixClock:%lu(real)\n", clk_get_rate(ingenicfb->pclk));
+	}
+
+	//	ingenicfb_config_image_enh(info);
+	if (pdata->lcd_type == LCD_TYPE_SLCD) {
+		ingenicfb_slcd_mcu_init(info);
+
+#ifdef CONFIG_SLCDC_CONTINUA
+		smart_ctrl &= ~SLCDC_CTRL_DMA_MODE;
+#else
+		smart_ctrl |= SLCDC_CTRL_DMA_START;
+#endif
+		smart_ctrl |= SLCDC_CTRL_DMA_EN;
+
+#ifdef CONFIG_SLCDC_USE_TE
+		smart_ctrl &= ~SLCDC_CTRL_NOT_USE_TE;
+#endif
+
+		if (pdata->smart_config.newcfg_fmt_conv) {
+			smart_new_cfg = reg_read(ingenicfb, SLCDC_CFG_NEW);
+			smart_new_cfg |= SLCDC_NEW_CFG_FMT_CONV_EN;
+			reg_write(ingenicfb, SLCDC_CFG_NEW, smart_new_cfg);
+		}
+		if (pdata->smart_config.bus_width == 9) {
+			smart_new_cfg = reg_read(ingenicfb, SLCDC_CFG_NEW);
+			smart_new_cfg &= ~(SMART_LCD_NEW_DWIDTH_MASK);
+			smart_new_cfg |= SMART_LCD_NEW_DWIDTH_9_BIT;
+			reg_write(ingenicfb, SLCDC_CFG_NEW, smart_new_cfg);
+		}
+		reg_write(ingenicfb, SLCDC_CTRL, smart_ctrl);
+	}
+
+	if (is_lcd_en) {
+		ingenicfb_enable(info);
+	}
+
+	ingenicfb->is_inited = 1;
+	return 0;
+}
+
+static int ingenicfb_blank(int blank_mode, struct fb_info *info)
+{
+	int count = 10000;
+	unsigned long ctrl;
+	struct ingenicfb *ingenicfb = info->par;
+
+	switch (blank_mode) {
+		case FB_BLANK_UNBLANK:
+			reg_write(ingenicfb, LCDC_STATE, 0);
+			reg_write(ingenicfb, LCDC_OSDS, 0);
+			ctrl = reg_read(ingenicfb, LCDC_CTRL);
+			ctrl |= LCDC_CTRL_ENA;
+			ctrl &= ~LCDC_CTRL_DIS;
+			reg_write(ingenicfb, LCDC_CTRL, ctrl);
+
+			mutex_lock(&ingenicfb->suspend_lock);
+			if (ingenicfb->is_suspend) {
+				ingenicfb->is_suspend = 0;
+				mutex_unlock(&ingenicfb->suspend_lock);
+			} else {
+				mutex_unlock(&ingenicfb->suspend_lock);
+			}
+			ingenicfb->is_lcd_en = 1;
+			break;
+		default:
+			if (ingenicfb->pdata->lcd_type != LCD_TYPE_SLCD) {
+				ctrl = reg_read(ingenicfb, LCDC_CTRL);
+				ctrl |= LCDC_CTRL_DIS;
+				reg_write(ingenicfb, LCDC_CTRL, ctrl);
+				while (!(reg_read(ingenicfb, LCDC_STATE) & LCDC_STATE_LDD)
+						&& count--) {
+					udelay(10);
+				}
+				if (count >= 0) {
+					ctrl = reg_read(ingenicfb, LCDC_STATE);
+					ctrl &= ~LCDC_STATE_LDD;
+					reg_write(ingenicfb, LCDC_STATE, ctrl);
+				} else {
+					dev_err(ingenicfb->dev, "LCDC disable state wrong\n");
+				}
+			} else {
+				ctrl = reg_read(ingenicfb, LCDC_CTRL);
+				ctrl &= ~LCDC_CTRL_ENA;
+				reg_write(ingenicfb, LCDC_CTRL, ctrl);
+
+				ctrl = reg_read(ingenicfb, SLCDC_CTRL);
+				ctrl &= ~SLCDC_CTRL_DMA_EN;
+				reg_write(ingenicfb, SLCDC_CTRL, ctrl);
+			}
+			ingenicfb->is_lcd_en = 0;
+	}
+
+	return 0;
+}
+
+static int ingenicfb_alloc_devmem(struct ingenicfb *ingenicfb)
+{
+	int i;
+	unsigned int videosize = 0;
+	struct fb_videomode *mode;
+	void *page;
+
+	ingenicfb->framedesc[0] =
+		dma_alloc_coherent(ingenicfb->dev,
+				sizeof(struct ingenicfb_framedesc) * ingenicfb->desc_num,
+				&ingenicfb->framedesc_phys, GFP_KERNEL);
+	if (!ingenicfb->framedesc[0])
+		return -ENOMEM;
+	for (i = 1; i < ingenicfb->desc_num; i++){
+		ingenicfb->framedesc[i] = ingenicfb->framedesc[0] + i;
+	}
+
+	mode = ingenicfb->pdata->modes;
+	if (!mode) {
+		dev_err(ingenicfb->dev, "Checkout video mode fail\n");
+		return -EINVAL;
+	}
+
+	if (mode->flag & FB_MODE_IS_VGA) {
+		mode = ingenicfb_checkout_max_vga_videomode(ingenicfb->fb);
+		if (!mode) {
+			dev_err(ingenicfb->dev,
+					"Checkout VGA max pix video mode fail\n");
+			return -EINVAL;
+		}
+	}
+
+	videosize = ALIGN(mode->xres, PIXEL_ALIGN) * mode->yres;
+	videosize *= ingenicfb_get_controller_bpp(ingenicfb) >> 3;
+	videosize *= NUM_FRAME_BUFFERS;
+
+	ingenicfb->vidmem_size = PAGE_ALIGN(videosize);
+
+	/**
+	 * Use the dma alloc coherent has waste some space,
+	 * If you need to alloc buffer for dma, open it,
+	 * else close it and use the Kmalloc.
+	 * And in ingenicfb_free_devmem() function is also set.
+	 */
+	ingenicfb->vidmem = dma_alloc_coherent(ingenicfb->dev,
+			ingenicfb->vidmem_size,
+			&ingenicfb->vidmem_phys, GFP_KERNEL);
+	if (!ingenicfb->vidmem)
+		return -ENOMEM;
+	for (page = ingenicfb->vidmem;
+			page < ingenicfb->vidmem + PAGE_ALIGN(ingenicfb->vidmem_size);
+			page += PAGE_SIZE) {
+		SetPageReserved(virt_to_page(page));
+	}
+
+	if (ingenicfb->pdata->lcd_type == LCD_TYPE_SLCD) {
+		int i;
+		unsigned long *ptr;
+		ingenicfb->desc_cmd_vidmem = dma_alloc_coherent(ingenicfb->dev, PAGE_SIZE,
+				&ingenicfb->desc_cmd_phys,
+				GFP_KERNEL);
+		ptr = (unsigned long *)ingenicfb->desc_cmd_vidmem;
+		for (i = 0; i < ingenicfb->pdata->smart_config.length_cmd; i++) {
+			ptr[i] = ingenicfb->pdata->smart_config.write_gram_cmd[i];
+		}
+	}
+
+	dev_dbg(ingenicfb->dev, "Frame buffer size: %d bytes\n", ingenicfb->vidmem_size);
+
+	return 0;
+}
+
+static void ingenicfb_free_devmem(struct ingenicfb *ingenicfb)
+{
+	dma_free_coherent(ingenicfb->dev, ingenicfb->vidmem_size,
+			ingenicfb->vidmem, ingenicfb->vidmem_phys);
+	dma_free_coherent(ingenicfb->dev,
+			sizeof(struct ingenicfb_framedesc) * ingenicfb->desc_num,
+			ingenicfb->framedesc, ingenicfb->framedesc_phys);
+	if (ingenicfb->pdata->lcd_type == LCD_TYPE_SLCD) {
+		dma_free_coherent(ingenicfb->dev, PAGE_SIZE,
+				ingenicfb->desc_cmd_vidmem, ingenicfb->desc_cmd_phys);
+	}
+}
+
+#define SPEC_TIME_IN_NS (1000*1000000)  /* 1s */
+static int ingenicfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int next_frm;
+	unsigned int tmp = 0;
+	struct ingenicfb *ingenicfb = info->par;
+
+	{/*debug*/
+		static struct timespec time_now, time_last;
+		struct timespec time_interval;
+		long long  interval_in_ns;
+		unsigned int interval_in_ms;
+		static unsigned int fpsCount = 0;
+
+		ingenicfb->pan_display_count++;
+		if(showFPS){
+			switch(showFPS){
+				case 1:
+					fpsCount++;
+					time_now = current_kernel_time();
+					time_interval = timespec_sub(time_now, time_last);
+					interval_in_ns = timespec_to_ns(&time_interval);
+					if ( interval_in_ns > SPEC_TIME_IN_NS ) {
+						printk(KERN_DEBUG " Pan display FPS: %d\n",fpsCount);
+						fpsCount = 0;
+						time_last = time_now;
+					}
+					break;
+				case 2:
+					time_now = current_kernel_time();
+					time_interval = timespec_sub(time_now, time_last);
+					interval_in_ns = timespec_to_ns(&time_interval);
+					interval_in_ms = (unsigned long)interval_in_ns/1000000;
+					printk(KERN_DEBUG " Pan display interval: %d\n",interval_in_ms);
+					time_last = time_now;
+					break;
+				default:
+					break;
+			}
+		}
+	}/*end debug*/
+	if (var->xoffset - info->var.xoffset) {
+		dev_err(info->dev, "No support for X panning for now\n");
+		return -EINVAL;
+	}
+
+	if (var->yres == 720 || var->yres == 1080) {	/* work around for HDMI device */
+		switch (var->yoffset) {
+			case 1440:
+			case (1080 * 2):
+				next_frm = 2;
+				break;
+			case 720:
+			case (1080 * 1):
+				next_frm = 1;
+				break;
+			default:
+				next_frm = 0;
+				break;
+		}
+	} else
+		next_frm = var->yoffset / var->yres;
+
+	ingenicfb->current_buffer = next_frm;
+
+	if (ingenicfb->pdata->lcd_type != LCD_TYPE_INTERLACED_TV &&
+			ingenicfb->pdata->lcd_type != LCD_TYPE_SLCD) {
+		if (!ingenicfb->osd.block) {
+			ingenicfb->framedesc[0]->databuf = ingenicfb->vidmem_phys
+				+ ingenicfb->frm_size * next_frm;
+		} else {
+			/* 16x16 block mode */
+		}
+	} else if (ingenicfb->pdata->lcd_type == LCD_TYPE_SLCD) {
+		/* smart tft spec code here */
+		ingenicfb->framedesc[0]->databuf = ingenicfb->vidmem_phys
+			+ ingenicfb->frm_size * next_frm;
+		if (!ingenicfb->is_lcd_en)
+			return -EINVAL;;
+
+		if (ingenicfb->pdata->lcd_callback_ops.dma_transfer_begin){
+			ingenicfb->pdata->lcd_callback_ops.dma_transfer_begin(ingenicfb);
+			tmp = reg_read(ingenicfb, SLCDC_CTRL);
+			tmp |= SLCDC_CTRL_DMA_START | SLCDC_CTRL_DMA_MODE;
+			reg_write(ingenicfb, SLCDC_CTRL, tmp);
+		}else{
+			tmp = reg_read(ingenicfb, SLCDC_CTRL);
+			tmp |= SLCDC_CTRL_DMA_START | SLCDC_CTRL_DMA_MODE;
+			reg_write(ingenicfb, SLCDC_CTRL, tmp);
+		}
+	} else {
+		/* LCD_TYPE_INTERLACED_TV */
+	}
+
+	return 0;
+}
+
+static void ingenicfb_set_alpha(struct fb_info *info, struct ingenicfb_fg_alpha *fg_alpha)
+{
+	int i;
+	int desc_num;
+	uint32_t cfg;
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_framedesc *framedesc;
+
+	if (!fg_alpha->fg) {
+		desc_num = ingenicfb->desc_num - 1;
+		framedesc = ingenicfb->framedesc[0];
+	} else {
+		desc_num = 1;
+		framedesc = ingenicfb->fg1_framedesc;
+	}
+
+	cfg = reg_read(ingenicfb, LCDC_OSDC);
+	if (fg_alpha->enable) {
+		cfg |= LCDC_OSDC_ALPHAEN;
+		for (i = 0; i < desc_num; i++) {
+			if (!fg_alpha->mode) {
+				(framedesc + i)->cpos &= ~LCDC_CPOS_ALPHAMD1;
+			} else {
+				(framedesc + i)->cpos |= LCDC_CPOS_ALPHAMD1;
+			}
+			(framedesc + i)->desc_size &= ~LCDC_DESSIZE_ALPHA_MASK;
+			(framedesc + i)->desc_size |= (fg_alpha->value <<
+					LCDC_DESSIZE_ALPHA_BIT
+					&
+					LCDC_DESSIZE_ALPHA_MASK);
+		}
+	} else {
+		dev_info(info->dev, "Failed to set alpha\n");
+	}
+	//	reg_write(ingenicfb, LCDC_OSDC, cfg);
+}
+
+	static void
+ingenicfb_set_background(struct fb_info *info, struct ingenicfb_bg *background)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	uint32_t bg_value;
+
+	bg_value = background->red << LCDC_BGC_RED_OFFSET & LCDC_BGC_RED_MASK;
+	bg_value |= (background->green << LCDC_BGC_GREEN_OFFSET
+			& LCDC_BGC_GREEN_MASK);
+	bg_value |=
+		(background->blue << LCDC_BGC_BLUE_OFFSET & LCDC_BGC_BLUE_MASK);
+
+	if (!background->fg)
+		reg_write(ingenicfb, LCDC_BGC0, bg_value);
+	else
+		reg_write(ingenicfb, LCDC_BGC1, bg_value);
+}
+
+	static void
+ingenicfb_set_colorkey(struct fb_info *info, struct ingenicfb_color_key *color_key)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	uint32_t tmp = 0;
+
+	if (color_key->mode == 1) {
+		tmp |= LCDC_KEY_KEYMD;
+	} else {
+		tmp &= ~LCDC_KEY_KEYMD;
+	}
+
+	tmp |= (color_key->red << LCDC_KEY_RED_OFFSET & LCDC_KEY_RED_MASK);
+	tmp |=
+		(color_key->green << LCDC_KEY_GREEN_OFFSET & LCDC_KEY_GREEN_MASK);
+	tmp |= (color_key->blue << LCDC_KEY_BLUE_OFFSET & LCDC_KEY_BLUE_MASK);
+	tmp |= LCDC_KEY_KEYEN;
+
+	if (!color_key->fg) {
+		reg_write(ingenicfb, LCDC_KEY0, tmp);
+		tmp = reg_read(ingenicfb, LCDC_KEY0);
+	} else {
+		reg_write(ingenicfb, LCDC_KEY1, tmp);
+		tmp = reg_read(ingenicfb, LCDC_KEY1);
+	}
+
+	if (color_key->enable == 1) {
+		tmp |= LCDC_KEY_KEYEN;
+	} else {
+		tmp &= ~LCDC_KEY_KEYEN;
+	}
+	if (!color_key->fg) {
+		reg_write(ingenicfb, LCDC_KEY0, tmp);
+	} else {
+		reg_write(ingenicfb, LCDC_KEY1, tmp);
+	}
+}
+
+	static int
+ingenicfb_set_foreground_position(struct fb_info *info, struct ingenicfb_fg_pos *fg_pos)
+{
+	int i;
+	int desc_num;
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_framedesc *framedesc;
+	struct fb_videomode *mode = info->mode;
+
+	if (!mode) {
+		dev_err(ingenicfb->dev, "%s, video mode is NULL\n", __func__);
+		return -EINVAL;
+	}
+	/*
+	 * The rules of f0, f1's position:
+	 * f0.x + f0.w <= panel.w;
+	 * f0.y + f0.h <= panel.h;
+	 */
+	if ((fg_pos->x + ingenicfb->osd.fg0.w > mode->xres) |
+			(fg_pos->y + ingenicfb->osd.fg0.h > mode->yres) |
+			(fg_pos->x >= mode->xres) | (fg_pos->y >= mode->yres)) {
+		dev_info(info->dev, "Invalid foreground position");
+		return -EINVAL;
+	}
+	ingenicfb->osd.fg0.x = fg_pos->x;
+	ingenicfb->osd.fg0.y = fg_pos->y;
+
+	if (!fg_pos->fg) {
+		desc_num = ingenicfb->desc_num - 1;
+		framedesc = ingenicfb->framedesc[0];
+	} else {
+		desc_num = 1;
+		framedesc = ingenicfb->fg1_framedesc;
+	}
+
+	for (i = 0; i < desc_num; i++) {
+		(framedesc + i)->cpos |= (((fg_pos->y << LCDC_CPOS_YPOS_BIT) &
+					LCDC_CPOS_YPOS_MASK) |
+				(fg_pos->x & LCDC_CPOS_XPOS_MASK));
+	}
+
+	return 0;
+}
+
+static int ingenicfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	int i;
+	unsigned int value;
+	unsigned int tmp;
+	void __user *argp = (void __user *)arg;
+	struct ingenicfb *ingenicfb = info->par;
+	struct ingenicfb_platform_data *pdata = ingenicfb->pdata;
+	struct fb_videomode *mode = info->mode;
+	int *buf;
+	unsigned long flags;
+
+	union {
+		struct ingenicfb_fg_pos fg_pos;
+		struct ingenicfb_fg_size fg_size;
+		struct ingenicfb_fg_alpha fg_alpha;
+		struct ingenicfb_bg background;
+		struct ingenicfb_color_key color_key;
+		struct ingenicfb_mode_res res;
+	} osd;
+
+	switch (cmd) {
+		case INGENICFB_GET_MODENUM:
+			copy_to_user(argp, &pdata->num_modes, sizeof(int));
+			break;
+		case INGENICFB_GET_MODELIST:
+			buf = kzalloc(sizeof(int) * pdata->num_modes, GFP_KERNEL);
+			for (i = 0; i < pdata->num_modes; i++) {
+				if (!pdata->modes[i].flag)
+					continue;
+				buf[i] = pdata->modes[i].flag;
+			}
+			copy_to_user(argp, buf, sizeof(int) * pdata->num_modes);
+			kzfree(buf);
+			break;
+		case INGENICFB_SET_VIDMEM:
+			if (copy_from_user
+					(&ingenicfb->vidmem_phys, argp, sizeof(unsigned int)))
+				return -EFAULT;
+			break;
+		case INGENICFB_SET_MODE:
+			if (copy_from_user(&value, argp, sizeof(int)))
+				return -EFAULT;
+
+			for (i = 0; i < pdata->num_modes; i++) {
+				if (pdata->modes[i].flag == value) {
+					ingenicfb_videomode_to_var(&info->var,
+							&pdata->modes[i],
+							ingenicfb->pdata->lcd_type);
+					return ingenicfb_set_par(info);
+				}
+			}
+			dev_info(info->dev, "Not find equal video mode at pdata");
+			return -EFAULT;
+			break;
+		case INGENICFB_ENABLE:
+			if (copy_from_user(&value, argp, sizeof(int))) {
+				dev_info(info->dev, "copy FB enable value failed\n");
+				return -EFAULT;
+			}
+
+			if (value) {
+				ingenicfb_enable(info);
+			} else {
+				ingenicfb_disable(info);
+			}
+			break;
+		case INGENICFB_SET_FG_SIZE:
+			if (copy_from_user
+					(&osd.fg_size, argp, sizeof(struct ingenicfb_fg_size))) {
+				dev_info(info->dev, "copy FG size from user failed\n");
+				return -EFAULT;
+			} else {
+				if (!mode) {
+					dev_err(ingenicfb->dev, "Video mode is NULL\n");
+					return -EINVAL;
+				}
+				if ((ingenicfb->osd.fg0.x + osd.fg_size.w > mode->xres) |
+						(ingenicfb->osd.fg0.y + osd.fg_size.h > mode->yres)) {
+					dev_info(info->dev, "Invalid foreground size");
+					return -EINVAL;
+				}
+				if (!osd.fg_size.fg) {
+					ingenicfb->osd.fg0.w = osd.fg_size.w;
+					ingenicfb->osd.fg0.h = osd.fg_size.h;
+					printk("this once called ingenicfb_prepare_dma_desc() in this function::%s00000000000000\n",__func__);
+					return ingenicfb_prepare_dma_desc(info);
+				} else {
+					/* LCDC DMA 1 is not used for now */
+				}
+			}
+			break;
+		case INGENICFB_GET_FG_SIZE:
+			if (copy_from_user
+					(&osd.fg_size, argp, sizeof(struct ingenicfb_fg_size))) {
+				dev_info(info->dev, "copy FG size from user failed\n");
+				return -EFAULT;
+			}
+
+			if (!osd.fg_size.fg) {
+				value = reg_read(ingenicfb, LCDC_SIZE0);
+			} else {
+				value = reg_read(ingenicfb, LCDC_SIZE1);
+			}
+			osd.fg_size.w = value & LCDC_SIZE_WIDTH_MASK;
+			osd.fg_size.h =
+				(value & LCDC_SIZE_HEIGHT_MASK) >> LCDC_SIZE_HEIGHT_BIT;
+			if (copy_to_user
+					(argp, &osd.fg_size, sizeof(struct ingenicfb_fg_size))) {
+				dev_info(info->dev, "copy FG size to user failed\n");
+				return -EFAULT;
+			}
+			break;
+		case INGENICFB_SET_FG_POS:
+			if (copy_from_user
+					(&osd.fg_pos, argp, sizeof(struct ingenicfb_fg_pos))) {
+				dev_info(info->dev, "copy FG pos from user failed\n");
+				return -EFAULT;
+			} else {
+				return ingenicfb_set_foreground_position(info, &osd.fg_pos);
+			}
+			break;
+		case INGENICFB_GET_FG_POS:
+			if (copy_from_user
+					(&osd.fg_pos, argp, sizeof(struct ingenicfb_fg_pos))) {
+				dev_info(info->dev, "copy FG pos from user failed\n");
+				return -EFAULT;
+			}
+			if (!osd.fg_size.fg) {
+				value = reg_read(ingenicfb, LCDC_XYP0);
+			} else {
+				value = reg_read(ingenicfb, LCDC_XYP1);
+			}
+			osd.fg_pos.x = value & LCDC_XYP_XPOS_MASK;
+			osd.fg_pos.y =
+				(value & LCDC_XYP_YPOS_MASK) >> LCDC_XYP_YPOS_BIT;
+			if (copy_to_user(argp, &osd.fg_pos, sizeof(struct ingenicfb_fg_pos))) {
+				dev_info(info->dev, "copy FG pos to user failed\n");
+				return -EFAULT;
+			}
+			break;
+		case INGENICFB_GET_BUFFER:
+			if (copy_to_user(argp, &ingenicfb->current_buffer, sizeof(int))) {
+				dev_info(info->dev, "user get current buffer failed\n");
+				return -EFAULT;
+			}
+			break;
+		case INGENICFB_SET_ALPHA:
+			if (copy_from_user
+					(&osd.fg_alpha, argp, sizeof(struct ingenicfb_fg_alpha))) {
+				dev_info(info->dev, "copy alpha from user failed\n");
+				return -EFAULT;
+			} else {
+				ingenicfb_set_alpha(info, &osd.fg_alpha);
+			}
+			break;
+		case INGENICFB_SET_VSYNCINT:
+			if (copy_from_user(&value, argp, sizeof(int)))
+				return -EFAULT;
+			spin_lock_irqsave(&ingenicfb->vsync_lock, flags);
+			if (value && (ingenicfb->is_vsync == 0)) {
+				/* clear previous EOF flag */
+				tmp = reg_read(ingenicfb, LCDC_STATE);
+				reg_write(ingenicfb, LCDC_STATE, tmp & ~LCDC_STATE_EOF);
+				/* enable end of frame interrupt */
+				tmp = reg_read(ingenicfb, LCDC_CTRL);
+				reg_write(ingenicfb, LCDC_CTRL, tmp | LCDC_CTRL_EOFM);
+			}
+			ingenicfb->is_vsync = value ? 1 : 2;
+			spin_unlock_irqrestore(&ingenicfb->vsync_lock, flags);
+			break;
+		case INGENICFB_SET_BACKGROUND:
+			if (copy_from_user
+					(&osd.background, argp, sizeof(struct ingenicfb_bg))) {
+				dev_info(info->dev, "copy colorkey from user failed\n");
+				return -EFAULT;
+			} else {
+				ingenicfb_set_background(info, &osd.background);
+			}
+			break;
+		case INGENICFB_SET_COLORKEY:
+			if (copy_from_user
+					(&osd.color_key, argp, sizeof(struct ingenicfb_color_key))) {
+				dev_info(info->dev, "copy colorkey from user failed\n");
+				return -EFAULT;
+			}
+			ingenicfb_set_colorkey(info, &osd.color_key);
+			break;
+		case INGENICFB_16X16_BLOCK_EN:
+			if (copy_from_user(&value, argp, sizeof(int)))
+				return -EFAULT;
+
+			if (value) {
+				dev_dbg(info->dev, "LCDC DMA enable block mode");
+				ingenicfb->osd.block = 1;
+				printk("this once called ingenicfb_prepare_dma_desc() in this function::%s00000000000000\n",__func__);
+				ingenicfb_prepare_dma_desc(info);
+			} else {
+				dev_dbg(info->dev, "LCDC DMA disable block mode");
+				ingenicfb->osd.block = 0;
+				printk("this once called ingenicfb_prepare_dma_desc() in this function::%s00000000000000\n",__func__);
+				ingenicfb_prepare_dma_desc(info);
+			}
+			break;
+		case INGENICFB_ENABLE_FG0:
+			if (copy_from_user(&value, argp, sizeof(int)))
+				return -EFAULT;
+			for (i = 0; i < ingenicfb->desc_num - 1; i++) {
+				if (value) {
+					ingenicfb->framedesc[i]->cmd |= LCDC_CMD_FRM_EN;
+				} else {
+					ingenicfb->framedesc[i]->cmd &= ~LCDC_CMD_FRM_EN;
+				}
+			}
+			break;
+		case INGENICFB_ENABLE_FG1:
+			if (copy_from_user(&value, argp, sizeof(int)))
+				return -EFAULT;
+			if (value) {
+				ingenicfb->fg1_framedesc->cmd |= LCDC_CMD_FRM_EN;
+			} else {
+				ingenicfb->fg1_framedesc->cmd &= ~LCDC_CMD_FRM_EN;
+			}
+			break;
+		default:
+			//		ingenicfb_image_enh_ioctl(info, cmd, arg);
+			break;
+	}
+
+	return 0;
+}
+
+static int ingenicfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	unsigned long start;
+	unsigned long off;
+	u32 len;
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	/* frame buffer memory */
+	start = ingenicfb->fb->fix.smem_start;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + ingenicfb->fb->fix.smem_len);
+	start &= PAGE_MASK;
+
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+	off += start;
+
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	vma->vm_flags |= VM_IO;
+
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+	/* Write-Acceleration */
+	pgprot_val(vma->vm_page_prot) |= _CACHE_CACHABLE_WA;
+
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+				vma->vm_end - vma->vm_start, vma->vm_page_prot))
+	{
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+/*
+static int ingenicfb_wait_for_vsync_thread(void *data)
+{
+	struct ingenicfb *ingenicfb = (struct ingenicfb *)data;
+	unsigned long flags;
+	unsigned int tmp;
+	char *envp[2];
+	ktime_t timestamp;
+
+	while (!kthread_should_stop()) {
+		wait_for_completion(&ingenicfb->vsync_wq);
+		mutex_lock(&ingenicfb->lock);
+//		 rotate right
+		ingenicfb->vsync_skip_map = (ingenicfb->vsync_skip_map >> 1 |
+				ingenicfb->vsync_skip_map << 9) &
+			0x3ff;
+		mutex_unlock(&ingenicfb->lock);
+		if (!(ingenicfb->vsync_skip_map & 0x1))
+			continue;
+
+		spin_lock_irqsave(&ingenicfb->vsync_lock, flags);
+		timestamp = ingenicfb->timestamp_array[ingenicfb->timestamp_thread_pos&(0xf)];
+		spin_unlock_irqrestore(&ingenicfb->vsync_lock, flags);
+
+		snprintf(ingenicfb->eventbuf, sizeof(ingenicfb->eventbuf), "VSYNC=%llu", ktime_to_ns(timestamp));
+		ingenicfb->timestamp_thread_pos++;
+		envp[0] = ingenicfb->eventbuf;
+		envp[1] = NULL;
+		kobject_uevent_env(&ingenicfb->dev->kobj, KOBJ_CHANGE, envp);
+
+		spin_lock_irqsave(&ingenicfb->vsync_lock, flags);
+		if(ingenicfb->is_vsync == 2) {
+			tmp = reg_read(ingenicfb, LCDC_CTRL);
+			reg_write(ingenicfb, LCDC_CTRL, tmp & ~LCDC_CTRL_EOFM);
+			ingenicfb->is_vsync = 0;
+		}
+		if(ingenicfb->timestamp_irq_pos == ingenicfb->timestamp_thread_pos)
+			ingenicfb->timestamp_irq_pos = ingenicfb->timestamp_thread_pos = 0;
+		spin_unlock_irqrestore(&ingenicfb->vsync_lock, flags);
+	}
+
+	return 0;
+}
+*/
+static irqreturn_t ingenicfb_irq_handler(int irq, void *data)
+{
+	unsigned int state;
+	struct ingenicfb *ingenicfb = (struct ingenicfb *)data;
+
+	state = reg_read(ingenicfb, LCDC_STATE);
+
+	if (state & LCDC_STATE_EOF) {
+		reg_write(ingenicfb, LCDC_STATE, state & ~LCDC_STATE_EOF);
+		wmb();
+		ingenicfb->timestamp_array[ingenicfb->timestamp_irq_pos&(0xf)] = ktime_get();
+		ingenicfb->timestamp_irq_pos++;
+		complete(&ingenicfb->vsync_wq);
+	}
+
+	if (state & LCDC_STATE_OFU) {
+		reg_write(ingenicfb, LCDC_STATE, state & ~LCDC_STATE_OFU);
+		if (ingenicfb->irq_cnt++ > 100) {
+			unsigned int tmp;
+			ingenicfb->irq_cnt = 0;
+			tmp = reg_read(ingenicfb, LCDC_CTRL);
+			reg_write(ingenicfb, LCDC_CTRL, tmp & ~LCDC_CTRL_OFUM);
+			dev_err(ingenicfb->dev, "disable OFU irq\n");
+		}
+		/* dev_err(ingenicfb->dev, "%s, Out FiFo underrun\n", __func__); */
+	}
+	return IRQ_HANDLED;
+}
+
+static struct fb_ops ingenicfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = ingenicfb_open,
+	.fb_release = ingenicfb_release,
+	.fb_check_var = ingenicfb_check_var,
+	.fb_set_par = ingenicfb_set_par,
+	.fb_blank = ingenicfb_blank,
+	.fb_pan_display = ingenicfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_ioctl = ingenicfb_ioctl,
+	.fb_mmap = ingenicfb_mmap,
+};
+
+static void ingenicfb_change_dma_desc(struct fb_info *info)
+{
+	struct ingenicfb *ingenicfb = info->par;
+	struct fb_videomode *mode;
+#if 0
+	if (!ingenicfb->is_lcd_en) {
+		dev_err(ingenicfb->dev, "LCDC isn't enabled\n");
+		return;
+	}
+#endif
+
+	mode = ingenicfb->pdata->modes;
+	if (!mode)
+		return;
+	ingenicfb->osd.fg0.fg = 0;
+	ingenicfb->osd.fg0.bpp = ingenicfb_get_controller_bpp(ingenicfb) == 32 ? 32 : 16;
+	ingenicfb->osd.fg0.x = ingenicfb->osd.fg0.y = 0;
+	ingenicfb->osd.fg0.w = mode->xres;
+	ingenicfb->osd.fg0.h = mode->yres;
+
+	info->mode = mode;
+	printk("this once called ingenicfb_prepare_dma_desc() in this function::%s00000000000000\n",__func__);
+	ingenicfb_prepare_dma_desc(info);
+
+	if (mode->pixclock) {
+		unsigned long rate = PICOS2KHZ(mode->pixclock) * 1000;
+		ingenicfb_pclk_disable(ingenicfb);
+		clk_set_rate(ingenicfb->pclk, rate);
+		ingenicfb_pclk_enable(ingenicfb);
+		dev_dbg(ingenicfb->dev, "LCDC: PixClock = %lu\n", rate);
+		dev_dbg(ingenicfb->dev, "LCDC: PixClock = %lu(real)\n",
+				clk_get_rate(ingenicfb->pclk));
+	} else {
+		dev_err(ingenicfb->dev, "Video mode pixclock invalid\n");
+	}
+
+	//	ingenicfb_config_image_enh(info);
+
+#ifndef CONFIG_SLCDC_CONTINUA
+	if (ingenicfb->pdata->lcd_type == LCD_TYPE_SLCD) {
+		/* update display */
+		unsigned long tmp;
+		tmp = reg_read(ingenicfb, SLCDC_CTRL);
+		tmp |= SLCDC_CTRL_DMA_MODE | SLCDC_CTRL_DMA_START;
+		reg_write(ingenicfb, SLCDC_CTRL, tmp);
+	}
+#else
+	reg_write(ingenicfb, SLCDC_CTRL, reg_read(ingenicfb, SLCDC_CTRL) & ~SLCDC_CTRL_DMA_MODE);
+#endif
+}
+
+static int ingenicfb_copy_logo(struct fb_info *info)
+{
+	unsigned long src_addr = 0;	/* u-boot logo buffer address */
+	unsigned long dst_addr = 0;	/* kernel frame buffer address */
+	unsigned long size;
+	unsigned long offsize;
+	int i = 0, j = 0;
+	struct ingenicfb *ingenicfb = info->par;
+
+	/* get buffer physical address */
+	src_addr = (unsigned long)reg_read(ingenicfb, LCDC_SA0);
+	if (!(reg_read(ingenicfb, LCDC_CTRL) & LCDC_CTRL_ENA)) {
+		/* u-boot is not display logo */
+		printk("uboot lcd is not enabled!!!\n");
+		return -ENOMEM;
+	}
+
+	printk("uboot lcd is enabled!!\n");
+	ingenicfb->is_lcd_en = 1;
+
+	if (src_addr) {
+		src_addr = (unsigned long)phys_to_virt(src_addr);
+		if (ALIGN(info->var.xres, PIXEL_ALIGN) == info->var.xres) {
+			size = info->fix.line_length * info->var.yres;
+
+			for (i = 0; i < NUM_FRAME_BUFFERS; i++) {
+				dst_addr = (unsigned long)info->screen_base + i * size;
+				memcpy((void *)dst_addr, (void *)src_addr, size);
+			}
+		} else {
+			size = info->var.bits_per_pixel * info->var.xres >> 3;
+			offsize = info->var.bits_per_pixel * (ALIGN(info->var.xres, PIXEL_ALIGN) - info->var.xres) >> 3;
+
+			dst_addr = (unsigned long)info->screen_base;
+			for (i = 0; i < NUM_FRAME_BUFFERS; i++) {
+				unsigned long temp_src_addr = src_addr;
+				for (j = 0; j < info->var.yres; j++) {
+					memcpy((void *)dst_addr, (void *)temp_src_addr, size);
+					dst_addr += (size + offsize);
+					temp_src_addr += size;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void ingenicfb_display_v_color_bar(struct fb_info *info)
+{
+	int i, j;
+	int w, h;
+	int bpp;
+	unsigned short *p16;
+	unsigned int *p32;
+	struct ingenicfb *ingenicfb = info->par;
+	struct fb_videomode *mode = ingenicfb->pdata->modes;
+
+	if (!mode) {
+		dev_err(ingenicfb->dev, "%s, video mode is NULL\n", __func__);
+		return;
+	}
+	if (!ingenicfb->vidmem_phys) {
+		dev_err(ingenicfb->dev, "Not allocate frame buffer yet\n");
+		return;
+	}
+	if (!ingenicfb->vidmem)
+		ingenicfb->vidmem = (void *)(ingenicfb->vidmem_phys+0x80000000);
+	p16 = (unsigned short *)ingenicfb->vidmem;
+	p32 = (unsigned int *)ingenicfb->vidmem;
+	w = ingenicfb->osd.fg0.w;
+	h = ingenicfb->osd.fg0.h;
+	bpp = ingenicfb->osd.fg0.bpp;
+
+	dev_info(info->dev,
+			"LCD V COLOR BAR w,h,bpp(%d,%d,%d) ingenicfb->vidmem=%p\n", w, h,
+			bpp, ingenicfb->vidmem);
+
+	for (i = 0; i < h; i++) {
+		for (j = 0; j < w; j++) {
+			short c16;
+			int c32 = 0;
+			switch ((j / 10) % 4) {
+				case 0:
+					c16 = 0xF800;
+					c32 = 0xFFFF0000;
+					break;
+				case 1:
+					c16 = 0x07C0;
+					c32 = 0xFF00FF00;
+					break;
+				case 2:
+					c16 = 0x001F;
+					c32 = 0xFF0000FF;
+					break;
+				default:
+					c16 = 0xFFFF;
+					c32 = 0xFFFFFFFF;
+					break;
+			}
+			switch (bpp) {
+				case 18:
+				case 24:
+				case 32:
+					*p32++ = c32;
+					break;
+				default:
+					*p16++ = c16;
+			}
+		}
+		if (w % PIXEL_ALIGN) {
+			switch (bpp) {
+				case 18:
+				case 24:
+				case 32:
+					p32 += (ALIGN(mode->xres, PIXEL_ALIGN) - w);
+					break;
+				default:
+					p16 += (ALIGN(mode->xres, PIXEL_ALIGN) - w);
+					break;
+			}
+		}
+	}
+}
+
+static void ingenicfb_display_h_color_bar(struct fb_info *info)
+{
+	int i, j;
+	int w, h;
+	int bpp;
+	unsigned short *p16;
+	unsigned int *p32;
+	struct ingenicfb *ingenicfb = info->par;
+	struct fb_videomode *mode = ingenicfb->pdata->modes;
+
+	if (!mode) {
+		dev_err(ingenicfb->dev, "%s, video mode is NULL\n", __func__);
+		return;
+	}
+	if (!ingenicfb->vidmem_phys) {
+		dev_err(ingenicfb->dev, "Not allocate frame buffer yet\n");
+		return;
+	}
+	if (!ingenicfb->vidmem)
+		ingenicfb->vidmem = (void *)(ingenicfb->vidmem_phys + 0x80000000);
+	p16 = (unsigned short *)ingenicfb->vidmem;
+	p32 = (unsigned int *)ingenicfb->vidmem;
+	w = ingenicfb->osd.fg0.w;
+	h = ingenicfb->osd.fg0.h;
+	bpp = ingenicfb->osd.fg0.bpp;
+
+	dev_info(info->dev,
+			"LCD H COLOR BAR w,h,bpp(%d,%d,%d), ingenicfb->vidmem=%p\n", w, h,
+			bpp, ingenicfb->vidmem);
+
+	for (i = 0; i < h; i++) {
+		for (j = 0; j < w; j++) {
+			short c16;
+			int c32;
+			switch ((i / 10) % 4) {
+				case 0:
+					c16 = 0xF800;
+					c32 = 0x00FF0000;
+					break;
+				case 1:
+					c16 = 0x07C0;
+					c32 = 0x0000FF00;
+					break;
+				case 2:
+					c16 = 0x001F;
+					c32 = 0x000000FF;
+					break;
+				default:
+					c16 = 0xFFFF;
+					c32 = 0xFFFFFFFF;
+					break;
+			}
+			switch (bpp) {
+				case 18:
+				case 24:
+				case 32:
+					*p32++ = c32;
+					break;
+				default:
+					*p16++ = c16;
+			}
+		}
+		if (w % PIXEL_ALIGN) {
+			switch (bpp) {
+				case 18:
+				case 24:
+				case 32:
+					p32 += (ALIGN(mode->xres, PIXEL_ALIGN) - w);
+					break;
+				default:
+					p16 += (ALIGN(mode->xres, PIXEL_ALIGN) - w);
+					break;
+			}
+		}
+	}
+}
+static void dump_lcdc_registers(struct ingenicfb *ingenicfb)
+{
+	int i;
+	long unsigned int tmp;
+	struct device *dev = ingenicfb->dev;
+
+	// is_clk_en = ingenicfb->is_clk_en;
+	// ingenicfb_clk_enable(ingenicfb);
+
+	/* LCD Controller Resgisters */
+	dev_info(dev, "ingenicfb->base:\t0x%08x\n", (unsigned int)(ingenicfb->base));
+
+	dev_info(dev, "LCDC_CFG:(0x%08x)\t0x%08lx\n",LCDC_CFG, reg_read(ingenicfb, LCDC_CFG));
+	dev_info(dev, "LCDC_CTRL:(0x%08x)\t0x%08lx\n", LCDC_CTRL,reg_read(ingenicfb, LCDC_CTRL));
+	dev_info(dev, "LCDC_STATE:(0x%08x)\t0x%08lx\n",LCDC_STATE, reg_read(ingenicfb, LCDC_STATE));
+	dev_info(dev, "LCDC_OSDC:(0x%08x)\t0x%08lx\n",LCDC_OSDC, reg_read(ingenicfb, LCDC_OSDC));
+	dev_info(dev, "LCDC_OSDCTRL:(0x%08x)\t0x%08lx\n",LCDC_OSDCTRL, reg_read(ingenicfb, LCDC_OSDCTRL));
+	dev_info(dev, "LCDC_OSDS:(0x%08x)\t0x%08lx\n",LCDC_OSDS, reg_read(ingenicfb, LCDC_OSDS));
+	dev_info(dev, "LCDC_BGC0:(0x%08x)\t0x%08lx\n",LCDC_BGC0, reg_read(ingenicfb, LCDC_BGC0));
+	dev_info(dev, "LCDC_KEY0:(0x%08x)\t0x%08lx\n",LCDC_KEY0, reg_read(ingenicfb, LCDC_KEY0));
+	dev_info(dev, "LCDC_ALPHA:(0x%08x)\t0x%08lx\n",LCDC_ALPHA, reg_read(ingenicfb, LCDC_ALPHA));
+	dev_info(dev, "LCDC_IPUR:(0x%08x)\t0x%08lx\n",LCDC_IPUR, reg_read(ingenicfb, LCDC_IPUR));
+	dev_info(dev, "==================================\n");
+	tmp = reg_read(ingenicfb, LCDC_VAT);
+	dev_info(dev, "LCDC_VAT:(0x%08x)\t0x%08lx, HT = %ld, VT = %ld\n",LCDC_VAT, tmp,
+			(tmp & LCDC_VAT_HT_MASK) >> LCDC_VAT_HT_BIT,
+			(tmp & LCDC_VAT_VT_MASK) >> LCDC_VAT_VT_BIT);
+	tmp = reg_read(ingenicfb, LCDC_DAH);
+	dev_info(dev, "LCDC_DAH:(0x%08x)\t0x%08lx, HDS = %ld, HDE = %ld\n", LCDC_DAH,tmp,
+			(tmp & LCDC_DAH_HDS_MASK) >> LCDC_DAH_HDS_BIT,
+			(tmp & LCDC_DAH_HDE_MASK) >> LCDC_DAH_HDE_BIT);
+	tmp = reg_read(ingenicfb, LCDC_DAV);
+	dev_info(dev, "LCDC_DAV:(0x%08x)\t0x%08lx, VDS = %ld, VDE = %ld\n", LCDC_DAV,tmp,
+			(tmp & LCDC_DAV_VDS_MASK) >> LCDC_DAV_VDS_BIT,
+			(tmp & LCDC_DAV_VDE_MASK) >> LCDC_DAV_VDE_BIT);
+	tmp = reg_read(ingenicfb, LCDC_HSYNC);
+	dev_info(dev, "LCDC_HSYNC:(0x%08x)\t0x%08lx, HPS = %ld, HPE = %ld\n", LCDC_HSYNC,tmp,
+			(tmp & LCDC_HSYNC_HPS_MASK) >> LCDC_HSYNC_HPS_BIT,
+			(tmp & LCDC_HSYNC_HPE_MASK) >> LCDC_HSYNC_HPE_BIT);
+	tmp = reg_read(ingenicfb, LCDC_VSYNC);
+	dev_info(dev, "LCDC_VSYNC:(0x%08x)\t0x%08lx, VPS = %ld, VPE = %ld\n", LCDC_VSYNC,tmp,
+			(tmp & LCDC_VSYNC_VPS_MASK) >> LCDC_VSYNC_VPS_BIT,
+			(tmp & LCDC_VSYNC_VPE_MASK) >> LCDC_VSYNC_VPE_BIT);
+	dev_info(dev, "==================================\n");
+	dev_info(dev, "LCDC_XYP0:(0x%08x)\t0x%08lx\n",LCDC_XYP0, reg_read(ingenicfb, LCDC_XYP0));
+	dev_info(dev, "LCDC_SIZE0:(0x%08x)\t0x%08lx\n",LCDC_SIZE0, reg_read(ingenicfb, LCDC_SIZE0));
+	dev_info(dev, "LCDC_RGBC:(0x%08x) \t0x%08lx\n",LCDC_RGBC, reg_read(ingenicfb, LCDC_RGBC));
+	dev_info(dev, "LCDC_PS:(0x%08x)\t0x%08lx\n",LCDC_PS, reg_read(ingenicfb, LCDC_PS));
+	dev_info(dev, "LCDC_CLS:(0x%08x)\t0x%08lx\n",LCDC_CLS, reg_read(ingenicfb, LCDC_CLS));
+	dev_info(dev, "LCDC_SPL:(0x%08x)\t0x%08lx\n",LCDC_SPL, reg_read(ingenicfb, LCDC_SPL));
+	dev_info(dev, "LCDC_REV:(0x%08x)\t0x%08lx\n",LCDC_REV, reg_read(ingenicfb, LCDC_REV));
+	dev_info(dev, "LCDC_IID:(0x%08x)\t0x%08lx\n",LCDC_IID, reg_read(ingenicfb, LCDC_IID));
+	dev_info(dev, "==================================\n");
+	dev_info(dev, "LCDC_DA0:(0x%08x)\t0x%08lx\n",LCDC_DA0, reg_read(ingenicfb, LCDC_DA0));
+	dev_info(dev, "LCDC_SA0:(0x%08x)\t0x%08lx\n",LCDC_SA0, reg_read(ingenicfb, LCDC_SA0));
+	dev_info(dev, "LCDC_FID0:(0x%08x)\t0x%08lx\n",LCDC_FID0, reg_read(ingenicfb, LCDC_FID0));
+	dev_info(dev, "LCDC_CMD0:(0x%08x)\t0x%08lx\n",LCDC_CMD0, reg_read(ingenicfb, LCDC_CMD0));
+	dev_info(dev, "LCDC_OFFS0:(0x%08x)\t0x%08lx\n",LCDC_OFFS0, reg_read(ingenicfb, LCDC_OFFS0));
+	dev_info(dev, "LCDC_PW0:(0x%08x)\t0x%08lx\n", LCDC_PW0,reg_read(ingenicfb, LCDC_PW0));
+	dev_info(dev, "LCDC_CNUM0:(0x%08x)\t0x%08lx\n",LCDC_CNUM0, reg_read(ingenicfb, LCDC_CNUM0));
+	dev_info(dev, "LCDC_DESSIZE0:(0x%08x)\t0x%08lx\n",LCDC_DESSIZE0,
+			reg_read(ingenicfb, LCDC_DESSIZE0));
+	dev_info(dev, "==================================\n");
+	dev_info(dev, "LCDC_PCFG:(0x%08x)\t0x%08lx\n",LCDC_PCFG, reg_read(ingenicfb, LCDC_PCFG));
+	dev_info(dev, "==================================\n");
+	dev_info(dev, "SLCDC_CFG:(0x%08x) \t0x%08lx\n",SLCDC_CFG, reg_read(ingenicfb, SLCDC_CFG));
+	dev_info(dev, "SLCDC_CTRL:(0x%08x) \t0x%08lx\n",SLCDC_CTRL, reg_read(ingenicfb, SLCDC_CTRL));
+	dev_info(dev, "SLCDC_STATE:(0x%08x) \t0x%08lx\n",SLCDC_STATE, reg_read(ingenicfb, SLCDC_STATE));
+	dev_info(dev, "SLCDC_DATA:(0x%08x) \t0x%08lx\n",SLCDC_DATA, reg_read(ingenicfb, SLCDC_DATA));
+	dev_info(dev, "SLCDC_CFG_NEW:(0x%08x) \t0x%08lx\n",SLCDC_CFG_NEW,
+			reg_read(ingenicfb, SLCDC_CFG_NEW));
+	dev_info(dev, "SLCDC_WTIME:(0x%08x) \t0x%08lx\n",SLCDC_WTIME, reg_read(ingenicfb, SLCDC_WTIME));
+	dev_info(dev, "SLCDC_TAS:(0x%08x) \t0x%08lx\n",SLCDC_TAS, reg_read(ingenicfb, SLCDC_TAS));
+	dev_info(dev, "==================================\n");
+	printk("reg:0x10000020 value=0x%08x  (24bit) Clock Gate Register0\n",
+			*(unsigned int *)0xb0000020);
+	printk("reg:0x100000e4 value=0x%08x  (5bit_lcdc 21bit_lcdcs) Power Gate Register: \n",
+			*(unsigned int *)0xb00000e4);
+	printk("reg:0x100000b8 value=0x%08x  (10bit) SRAM Power Control Register0 \n",
+			*(unsigned int *)0xb00000b8);
+	printk("reg:0x10000064 value=0x%08x  Lcd pixclock \n",
+			*(unsigned int *)0xb0000064);
+	printk("==================================\n");
+	printk("PAINT:\t0x%08x\n", *(unsigned int *)0xb0010010);
+	printk("PAMASK:\t0x%08x\n",*(unsigned int *)0xb0010020);
+	printk("PAPAT1:\t0x%08x\n",*(unsigned int *)0xb0010030);
+	printk("PAPAT0:\t0x%08x\n",*(unsigned int *)0xb0010040);
+	printk("PBINT:\t0x%08x\n", *(unsigned int *)0xb0010110);
+	printk("PBMASK:\t0x%08x\n",*(unsigned int *)0xb0010120);
+	printk("PBPAT1:\t0x%08x\n",*(unsigned int *)0xb0010130);
+	printk("PBPAT0:\t0x%08x\n",*(unsigned int *)0xb0010140);
+	for (i = 0; i < ingenicfb->desc_num + 1; i++) {
+		if (!ingenicfb->framedesc[i])
+			break;
+		dev_info(dev, "==================================\n");
+		dev_info(dev, "ingenicfb->framedesc[%d]:       0x%p\n"  , i, ingenicfb->framedesc[i]);
+		dev_info(dev, "framedesc[%d]->next:       0x%08x\n", i, ingenicfb->framedesc[i]->next);
+		dev_info(dev, "framedesc[%d]->databuf:    0x%08x\n", i, ingenicfb->framedesc[i]->databuf);
+		dev_info(dev, "framedesc[%d]->id:         0x%08x\n", i, ingenicfb->framedesc[i]->id);
+		dev_info(dev, "framedesc[%d]->cmd:        0x%08x\n", i, ingenicfb->framedesc[i]->cmd);
+		dev_info(dev, "framedesc[%d]->offsize:    0x%08x\n", i, ingenicfb->framedesc[i]->offsize);
+		dev_info(dev, "framedesc[%d]->page_width: 0x%08x\n", i, ingenicfb->framedesc[i]->page_width);
+		dev_info(dev, "framedesc[%d]->cpos:       0x%08x\n", i, ingenicfb->framedesc[i]->cpos);
+		dev_info(dev, "framedesc[%d]->desc_size:  0x%08x\n", i, ingenicfb->framedesc[i]->desc_size);
+	}
+	// if (!is_clk_en)
+	//    ingenicfb_clk_disable(ingenicfb);
+
+	return;
+}
+
+	static ssize_t
+dump_lcd(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ingenicfb *ingenicfb = dev_get_drvdata(dev);
+	dump_lcdc_registers(ingenicfb);
+
+	return 0;
+}
+
+	static ssize_t
+dump_h_color_bar(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ingenicfb *ingenicfb = dev_get_drvdata(dev);
+	ingenicfb_display_h_color_bar(ingenicfb->fb);
+	return 0;
+}
+
+	static ssize_t
+dump_v_color_bar(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ingenicfb *ingenicfb = dev_get_drvdata(dev);
+	ingenicfb_display_v_color_bar(ingenicfb->fb);
+	return 0;
+}
+
+	static ssize_t
+vsync_skip_r(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ingenicfb *ingenicfb = dev_get_drvdata(dev);
+	mutex_lock(&ingenicfb->lock);
+	snprintf(buf, 3, "%d\n", ingenicfb->vsync_skip_ratio);
+	dev_dbg(dev, "vsync_skip_map = 0x%08x\n", ingenicfb->vsync_skip_map);
+	mutex_unlock(&ingenicfb->lock);
+	return 3;		/* sizeof ("%d\n") */
+}
+
+static int vsync_skip_set(struct ingenicfb *ingenicfb, int vsync_skip)
+{
+	unsigned int map_wide10 = 0;
+	int rate, i, p, n;
+	int fake_float_1k;
+
+	if (vsync_skip < 0 || vsync_skip > 9)
+		return -EINVAL;
+
+	rate = vsync_skip + 1;
+	fake_float_1k = 10000 / rate;	/* 10.0 / rate */
+
+	p = 1;
+	n = (fake_float_1k * p + 500) / 1000;	/* +0.5 to int */
+
+	for (i = 1; i <= 10; i++) {
+		map_wide10 = map_wide10 << 1;
+		if (i == n) {
+			map_wide10++;
+			p++;
+			n = (fake_float_1k * p + 500) / 1000;
+		}
+	}
+	mutex_lock(&ingenicfb->lock);
+	ingenicfb->vsync_skip_map = map_wide10;
+	ingenicfb->vsync_skip_ratio = rate - 1;	/* 0 ~ 9 */
+	mutex_unlock(&ingenicfb->lock);
+
+	return 0;
+}
+
+	static ssize_t
+vsync_skip_w(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct ingenicfb *ingenicfb = dev_get_drvdata(dev);
+
+	if ((count != 1) && (count != 2))
+		return -EINVAL;
+	if ((*buf < '0') && (*buf > '9'))
+		return -EINVAL;
+
+	vsync_skip_set(ingenicfb, *buf - '0');
+
+	return count;
+}
+
+static ssize_t fps_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	printk("\n-----you can choice print way:\n");
+	printk("Example: echo NUM > show_fps\n");
+	printk("NUM = 0: close fps statistics\n");
+	printk("NUM = 1: print recently fps\n");
+	printk("NUM = 2: print interval between last and this pan_display\n");
+	printk("NUM = 3: print pan_display count\n\n");
+	return 0;
+}
+
+static ssize_t fps_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t n)
+{
+	int num = 0;
+	num = simple_strtoul(buf, NULL, 0);
+	if(num < 0 || num > 3){
+		printk("\n--please 'cat show_fps' to view using the method\n\n");
+		return n;
+	}
+	showFPS = num;
+	if(showFPS == 3)
+		printk(KERN_DEBUG " Pand display count=%d\n",ingenicfb->pan_display_count);
+	return n;
+}
+/**********************lcd_debug***************************/
+// #include "foreground_width_test.c"          /* for foreground width test */
+
+static DEVICE_ATTR(dump_lcd, S_IRUGO|S_IWUSR, dump_lcd, NULL);
+static DEVICE_ATTR(dump_h_color_bar, S_IRUGO|S_IWUSR, dump_h_color_bar, NULL);
+static DEVICE_ATTR(dump_v_color_bar, S_IRUGO|S_IWUSR, dump_v_color_bar, NULL);
+static DEVICE_ATTR(vsync_skip, S_IRUGO|S_IWUSR, vsync_skip_r, vsync_skip_w);
+static DEVICE_ATTR(show_fps, S_IRUGO|S_IWUSR, fps_show, fps_store);
+#ifdef FOREGROUND_WIDTH_TEST
+static DEVICE_ATTR(partial_test, S_IRUGO|S_IWUSR, NULL, test_partial_refresh);
+#endif
+
+static struct attribute *lcd_debug_attrs[] = {
+	&dev_attr_dump_lcd.attr,
+	&dev_attr_dump_h_color_bar.attr,
+	&dev_attr_dump_v_color_bar.attr,
+	&dev_attr_vsync_skip.attr,
+	&dev_attr_show_fps.attr,
+#ifdef FOREGROUND_WIDTH_TEST
+	&dev_attr_partial_test.attr,
+#endif
+	NULL,
+};
+
+const char lcd_group_name[] = "debug";
+static struct attribute_group lcd_debug_attr_group = {
+	.name	= lcd_group_name,
+	.attrs	= lcd_debug_attrs,
+};
+
+
+void test_pattern(struct ingenicfb *ingenicfb)
+{
+	int count = 5;
+	int next_frm = 0;
+	//	dump_lcdc_registers(ingenicfb);
+	ingenicfb_set_par(ingenicfb->fb);
+	//	dump_lcdc_registers(ingenicfb);
+	ingenicfb_display_h_color_bar(ingenicfb->fb);
+
+	ingenicfb_enable(ingenicfb->fb);
+
+	//dump_lcdc_registers(ingenicfb);
+	while(count--){
+		if(next_frm){
+			next_frm = 0;
+			ingenicfb_display_v_color_bar(ingenicfb->fb);
+		}
+		else{
+			next_frm = 1;
+			ingenicfb_display_h_color_bar(ingenicfb->fb);
+		}
+		if (ingenicfb->pdata->lcd_type == LCD_TYPE_SLCD) {
+#ifndef CONFIG_SLCDC_CONTINUA
+			int smart_ctrl = 0;
+			smart_ctrl = reg_read(ingenicfb, SLCDC_CTRL);
+			smart_ctrl |= SLCDC_CTRL_DMA_START; //trigger a new frame
+			reg_write(ingenicfb, SLCDC_CTRL, smart_ctrl);
+#endif
+		}
+		mdelay(2000);
+	}
+}
+int lcd_display_inited_by_uboot( void )
+{
+	if (*(unsigned int*)(0xb3050000 + LCDC_CTRL) & LCDC_CTRL_ENA)
+		uboot_inited = 1;
+	else
+		uboot_inited = 0;
+	/* screen init will set this function first */
+	return uboot_inited;
+}
+
+static int ingenicfb_do_probe(struct platform_device *pdev, struct ingenicfb_platform_data *pdata)
+{
+	int ret = 0;
+	struct fb_info *fb;
+	struct fb_videomode *video_mode;
+	struct resource *mem;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "Missing platform data\n");
+		return -ENXIO;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "Failed to get register memory resource\n");
+		return -ENXIO;
+	}
+	mem = request_mem_region(mem->start, resource_size(mem), pdev->name);
+	if (!mem) {
+		dev_err(&pdev->dev,
+				"Failed to request register memory region\n");
+		return -EBUSY;
+	}
+
+
+	fb = framebuffer_alloc(sizeof(struct ingenicfb), &pdev->dev);
+	if (!fb) {
+		dev_err(&pdev->dev, "Failed to allocate framebuffer device\n");
+		ret = -ENOMEM;
+		goto err_release_mem_region;
+	}
+
+	fb->fbops = &ingenicfb_ops;
+	fb->flags = FBINFO_DEFAULT;
+
+	ingenicfb = fb->par;
+
+#if defined (CONFIG_LCD_FB_FORMAT_16BIT)
+	ingenicfb->fb_bpp = 16;
+#elif defined(CONFIG_LCD_FB_FORMAT_24BIT)
+	ingenicfb->fb_bpp = 24;
+#endif
+
+	ingenicfb->fb = fb;
+	ingenicfb->dev = &pdev->dev;
+	ingenicfb->pdata = pdata;
+	ingenicfb->mem = mem;
+	ingenicfb->is_lcd_en = 0;
+	if (pdata->lcd_type != LCD_TYPE_INTERLACED_TV &&
+			pdata->lcd_type != LCD_TYPE_SLCD) {
+		ingenicfb->desc_num = MAX_DESC_NUM - 2;
+	} else {
+		ingenicfb->desc_num = MAX_DESC_NUM;
+	}
+
+	mutex_init(&ingenicfb->lock);
+	mutex_init(&ingenicfb->suspend_lock);
+
+	sprintf(ingenicfb->clk_name, "gate_lcd");
+	sprintf(ingenicfb->pclk_name, "cgu_lcd");
+	ingenicfb->clk = devm_clk_get(&pdev->dev, ingenicfb->clk_name);
+	ingenicfb->pclk = devm_clk_get(&pdev->dev, ingenicfb->pclk_name);
+	if (IS_ERR(ingenicfb->clk) || IS_ERR(ingenicfb->pclk) ) {
+		ret = PTR_ERR(ingenicfb->clk);
+		dev_err(&pdev->dev, "Failed to get lcdc clock: %d\n", ret);
+		goto err_framebuffer_release;
+	}
+	/* Don't read or write lcdc registers until here. */
+	ingenicfb_clk_enable(ingenicfb);
+	ingenicfb_pclk_enable(ingenicfb);
+	/**(volatile unsigned int*)0xb0000064 = (1<<31) | (1<<28) | (0x13);
+	 *(volatile unsigned int*)0xb0000020 &= ~(1 << 23);*/
+	ingenicfb->base = ioremap(mem->start, resource_size(mem));
+	if (!ingenicfb->base) {
+		dev_err(&pdev->dev,
+				"Failed to ioremap register memory region\n");
+		ret = -EBUSY;
+		goto err_put_clk;
+	}
+
+	platform_set_drvdata(pdev, ingenicfb);
+
+	fb_videomode_to_modelist(pdata->modes, pdata->num_modes, &fb->modelist);
+	video_mode = ingenicfb->pdata->modes;
+	if (!video_mode)
+		goto err_iounmap;
+	ingenicfb_videomode_to_var(&fb->var, video_mode, ingenicfb->pdata->lcd_type);
+	fb->var.width = pdata->width;
+	fb->var.height = pdata->height;
+	fb->var.bits_per_pixel = ingenicfb->fb_bpp;
+
+	/* Android generic FrameBuffer format is A8B8G8R8(B3B2B1B0), so we set A8B8G8R8 as default.
+	 *
+	 * If set rgb order as A8B8G8R8, both SLCD cmd_buffer and data_buffer bytes sequence changed.
+	 * so remain slcd format X8R8G8B8, until fix this problem.(<lgwang@ingenic.cn>, 2014-06-20)
+	 */
+#ifdef CONFIG_ANDROID
+	if (pdata->lcd_type == LCD_TYPE_SLCD) {
+		ingenicfb->fmt_order = FORMAT_X8R8G8B8;
+	}
+	else {
+		ingenicfb->fmt_order = FORMAT_X8B8G8R8;
+	}
+#else
+	ingenicfb->fmt_order = FORMAT_X8R8G8B8;
+#endif
+
+	ingenicfb_check_var(&fb->var, fb);
+
+	ret = ingenicfb_alloc_devmem(ingenicfb);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to allocate video memory\n");
+		goto err_iounmap;
+	}
+	fb->fix = ingenicfb_fix;
+	fb->fix.line_length = fb->var.bits_per_pixel * ALIGN(fb->var.xres,
+			PIXEL_ALIGN) >> 3;
+	fb->fix.mmio_start = mem->start;
+	fb->fix.mmio_len = resource_size(mem);
+	fb->fix.smem_start = ingenicfb->vidmem_phys;
+	fb->fix.smem_len = ingenicfb->vidmem_size;
+	fb->screen_base = ingenicfb->vidmem;
+	fb->pseudo_palette = (void *)(fb + 1);
+	ingenicfb->irq = platform_get_irq(pdev, 0);
+	sprintf(ingenicfb->irq_name, "lcdc%d", pdev->id);
+	if (request_irq(ingenicfb->irq, ingenicfb_irq_handler, 0,
+				ingenicfb->irq_name, ingenicfb)) {
+		dev_err(&pdev->dev, "request irq failed\n");
+		ret = -EINVAL;
+		goto err_free_devmem;
+	}
+
+	ret = sysfs_create_group(&ingenicfb->dev->kobj, &lcd_debug_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "device create sysfs group failed\n");
+
+		ret = -EINVAL;
+		goto err_free_irq;
+	}
+
+	vsync_skip_set(ingenicfb, 0/*CONFIG_FB_VSYNC_SKIP*/);
+
+	init_completion(&ingenicfb->vsync_wq);
+	ingenicfb->timestamp_irq_pos = 0;
+	ingenicfb->timestamp_thread_pos = 0;
+	spin_lock_init(&ingenicfb->vsync_lock);
+/*	ingenicfb->vsync_thread = kthread_run(ingenicfb_wait_for_vsync_thread, ingenicfb, "ingenicfb-vsync");
+	if (ingenicfb->vsync_thread == ERR_PTR(-ENOMEM)) {
+		dev_err(&pdev->dev, "Failed to run vsync thread");
+		goto err_free_file;
+	}
+*/
+	ret = register_framebuffer(fb);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register framebuffer: %d\n",
+				ret);
+		goto err_kthread_stop;
+	}
+
+	if (ingenicfb->vidmem_phys) {
+		if (!ingenicfb_copy_logo(ingenicfb->fb)) {
+			ingenicfb_change_dma_desc(ingenicfb->fb);
+			ingenicfb->is_inited = 1;
+		} else {
+			ingenicfb->is_inited = 0;
+		}
+#ifdef CONFIG_FB_INGENIC_DEBUG
+		test_pattern(ingenicfb);
+#endif
+
+#ifdef CONFIG_SLCDC_LOW_POWER_CONSUMPTION
+		ingenicfb_disable(ingenicfb->fb);
+		ingenicfb_pclk_disable(ingenicfb);
+		ingenicfb_clk_disable(ingenicfb);
+#endif
+	}
+	return 0;
+
+err_kthread_stop:
+	kthread_stop(ingenicfb->vsync_thread);
+/*err_free_file:*/
+	sysfs_remove_group(&ingenicfb->dev->kobj, &lcd_debug_attr_group);
+err_free_irq:
+	free_irq(ingenicfb->irq, ingenicfb);
+err_free_devmem:
+	ingenicfb_free_devmem(ingenicfb);
+err_iounmap:
+	iounmap(ingenicfb->base);
+err_put_clk:
+err_framebuffer_release:
+	framebuffer_release(fb);
+err_release_mem_region:
+	release_mem_region(mem->start, resource_size(mem));
+	return ret;
+}
+
+static int ingenicfb_remove(struct platform_device *pdev)
+{
+	struct ingenicfb *ingenicfb = platform_get_drvdata(pdev);
+
+	kthread_stop(ingenicfb->vsync_thread);
+	ingenicfb_free_devmem(ingenicfb);
+	platform_set_drvdata(pdev, NULL);
+	sysfs_remove_group(&ingenicfb->dev->kobj, &lcd_debug_attr_group);
+
+	iounmap(ingenicfb->base);
+	release_mem_region(ingenicfb->mem->start, resource_size(ingenicfb->mem));
+
+	framebuffer_release(ingenicfb->fb);
+
+	return 0;
+}
+
+static void ingenicfb_shutdown(struct platform_device *pdev)
+{
+	struct ingenicfb *ingenicfb = platform_get_drvdata(pdev);
+	int is_fb_blank;
+	mutex_lock(&ingenicfb->suspend_lock);
+	is_fb_blank = (ingenicfb->is_suspend != 1);
+	ingenicfb->is_suspend = 1;
+	mutex_unlock(&ingenicfb->suspend_lock);
+	if (is_fb_blank)
+		fb_blank(ingenicfb->fb, FB_BLANK_POWERDOWN);
+};
+
+#ifdef CONFIG_PM
+
+static int ingenicfb_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct ingenicfb *ingenicfb = platform_get_drvdata(pdev);
+	mutex_lock(&ingenicfb->lock);
+	/* set suspend state and notify panel, backlight client */
+	fb_blank(ingenicfb->fb, FB_BLANK_POWERDOWN);
+	mutex_lock(&ingenicfb->suspend_lock);
+	ingenicfb->is_suspend = 1;
+	mutex_unlock(&ingenicfb->suspend_lock);
+	mutex_unlock(&ingenicfb->lock);
+
+	/*disable clock*/
+	ingenicfb_clk_disable(ingenicfb);
+	ingenicfb_pclk_disable(ingenicfb);
+
+	return 0;
+}
+
+static int ingenicfb_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct ingenicfb *ingenicfb = platform_get_drvdata(pdev);
+
+	fb_blank(ingenicfb->fb, FB_BLANK_UNBLANK);
+
+	/*enable clock*/
+	ingenicfb_clk_enable(ingenicfb);
+	ingenicfb_pclk_enable(ingenicfb);
+	ingenicfb_set_par(ingenicfb->fb);
+
+
+	mutex_lock(&ingenicfb->suspend_lock);
+	ingenicfb->is_suspend = 0;
+	mutex_unlock(&ingenicfb->suspend_lock);
+
+	ingenicfb_display_v_color_bar(ingenicfb->fb);
+	return 0;
+}
+
+static const struct dev_pm_ops ingenicfb_pm_ops = {
+	.suspend = ingenicfb_suspend,
+	.resume = ingenicfb_resume,
+};
+#endif
+int ingenicfb_register_panel(struct ingenicfb_platform_data *panel)
+{
+	WARN_ON(fbdev_panel != NULL);
+
+	fbdev_panel = panel;
+	if(fbdev_pdev != NULL) {
+		return ingenicfb_do_probe(fbdev_pdev, fbdev_panel);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ingenicfb_register_panel);
+
+static int ingenicfb_probe(struct platform_device *pdev)
+{
+	WARN_ON(fbdev_pdev != NULL);
+
+	fbdev_pdev = pdev;
+
+	if(fbdev_panel != NULL)
+		return ingenicfb_do_probe(fbdev_pdev, fbdev_panel);
+
+	return 0;
+}
+static const struct of_device_id ingenicfb_of_match[] = {
+	{ .compatible = "ingenic,lcd"},
+	{},
+};
+static struct platform_driver ingenicfb_driver = {
+	.probe = ingenicfb_probe,
+	.remove = ingenicfb_remove,
+	.shutdown = ingenicfb_shutdown,
+	.driver = {
+		.name = "ingenic-fb",
+		.of_match_table = ingenicfb_of_match,
+#ifdef CONFIG_PM
+		.pm = &ingenicfb_pm_ops,
+#endif
+
+	},
+};
+
+static int __init ingenicfb_init(void)
+{
+	platform_driver_register(&ingenicfb_driver);
+	return 0;
+}
+
+static void __exit ingenicfb_cleanup(void)
+{
+	platform_driver_unregister(&ingenicfb_driver);
+}
+
+#ifdef CONFIG_EARLY_INIT_RUN
+rootfs_initcall(ingenicfb_init);
+#else
+module_init(ingenicfb_init);
+#endif
+
+module_exit(ingenicfb_cleanup);
+
+MODULE_DESCRIPTION("ingenic LCD Controller driver");
+MODULE_AUTHOR("Sean Tang <ctang@ingenic.cn>");
+MODULE_LICENSE("GPL");
